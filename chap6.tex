\chapter{Design}
This chapter describes the internal wiring of the application and the reasons that lead to this design.
It explains the programming languages, frameworks and most relevant libraries, 

\section{Overview}
Reverse engineering the current project involves 3 activities related to technology and implementation details: \textbf{code restructuring}, \textbf{data restructuring} and\textbf{ forward engineering}.
No modifications in the code of the old version of Flango \cm are scheduled: there is no code or data restructuring.
However, there are some adaptations to be done in the \flangobe (\ac{API}), \ac{XML} and robotBehaviour:

\paragraph{Changes in \flangobe} The \ac{API} is designed to return \ac{XML} in all cases.
Most of the time this is desirable (e.g. requests to get screens) but in cases where normal exchange of information is done between the two systems, \ac{JSON} is a better option for the new technology.
It is less verbose (minimise bandwidth) and has a straight-forward translation to JavaScript objects.

\paragraph{Changes in \ac{XML}} The \ac{XML} syntax is designed to work isolated.
The new version, however, can mix \ac{XML} with \ac{HTML} thanks to Angular.
This leads to two problems:
\begin{itemize}
\item Some tags of the \ac{XML} vocabulary conflict with \ac{HTML}. For instance, \texttt{caption}. Solution: add a namespace \texttt{fl} to all tags. Thus, in the new version a \lstinline$<ui type="base-button"></ui>$ becomes \lstinline$<fl:ui fl:type="base-button"></fl:ui>$.
\end{itemize}

\paragraph{Changes in robotBehaviour} Current interoperation between Flango \cm and the robot is limited to robotBehaviour.
This communication is done with JavaScript callbacks and \acp{URL}.
To decouple the \cm as much as possible from the rest of the robot, the new system uses \ac{ROS} Topics and ROS Bridge

\subsection{Forward Engineering} A program that depends on an dead browser plug-in with performance issues is not sustainable.
A solution is completely  redesigning, recoding and retesting the program, even with a different technology that makes it more flexible, open to new developers and without performance problems.


\section{Technology}
angularJS (teach the browser new syntax), javascript, html5, Qt, QtBrowser and its limitations (JS engine vs chrome v8 or firefox's). tdd+jasmine

The project of this thesis, Flango \cm, is designed to work client side in a web browser.
The natural technology in this environment is JavaScript, HTML and CSS.
It uses the Google AngularJS framework with jQuery.
Angular \textit{teaches the browser new syntax}.
That is, instead of parsing the \ac{DOM} tree and building the \ac{GUI}, it defines the behaviour of new tags in \ac{HTML} documents that can be treated as regular \ac{HTML} nodes in the \ac{DOM}.
It interoperates with other systems built with a different technology: components in the robot use \ac{ROS} and the \flangobe has an \ac{API}. FIXME CROSS REF PHYISICAL DESIGN or CONTEXT

\subsection{JavaScript}
THIS SUBSECTION  IS NOT WRITTEN.

some hints. functional. scopes.
language, jquery, qr, swf

Object Literal Notation, constructors, closures, var scope, concept of classes
notes:

First thing you need to know is that JavaScript uses prototype-based inheritance. This means there is no distinction between classes and instances as in other OO languages (like Java). There are just objects. One implication of that is that differentiating between class and object diagrams does not make sense.

Keep in mind that UML includes many types of diagrams, specifically a branch of behavior diagrams, including sequence and use case diagrams. Such diagrams specifically address your concern of modeling javascript as a behavior driven language.

It is quite possible that a javascript system is not using object-oriented design. In such a case, class diagrams would probably not be appropriate, as you pointed out. However, since javascript does support object-oriented design, it is possible for class diagrams to effectively depict a system using javascript. It really depends on how the javascript is being used.

JavaScript is an
object-based
language. Just as in C\#, you can create objects, call their
methods, pass them as parameters, and so on. You could see this clearly when working
with the DOM, where you manipulated the HTML document through the methods
and properties of the implicit
document
object. However, JavaScript isn't generally
considered a fully object-oriented language because it lacks support for some features
that you'd
fi
nd in "real" OOP languages, or simply implements them differently.

 What does "object-oriented programming" mean anyway? Basically, as the name
suggests, OOP puts objects at the centre of the programming model. The
object
is
probably the most important concept in the world of OOPâ€”a self-contained entity
that has
state
and
behavior
, just like a real-world object. Each object is an instance of a
class
(also called
type
), which de
fi
nes the behavior that is shared by all its objects


******

description of the language and big uses
objects
functions
prototypal inheritance (vs classical model, new, etc)


\subsection{AngularJS}
The framework enforces a very strict separation of responsibilities: \ac{DOM} updates are abstracted away from model updates. 
Directives act as the layer that keeps the two parts loosely coupled.
On one hand, directives translate data into user interfaces and, on the other hand, directives translate user interactions back into \texttt{\$scope} behaviors. FIXME Reword this

\paragraph{Overview} AngularJS is a framework for dynamic web applications.
\ac{HTML} was created to declare static documents and needs libraries and frameworks to enable application development.
Angular lets developers use \ac{HTML} in the templates and extend the language syntax to express reusable components.
It \textit{teaches the browser new syntax} through a construct called Directive.
Features:
\begin{itemize}
    \item Tools to build \ac{CRUD} Applications: data-binding, basic templating directives, form validation, routing, deep-linking, reusable components, dependency injection.
    \item Tools to test: unit-testing, end-to-end testing, mocks.
\end{itemize}

Flango \cm reads \ac{XML} and renders it as \ac{HTML}.
There are two possible approaches: parsing the \ac{DOM} tree in the browser or teaching the browser new syntax.
This project uses the second (FIXME language: the latter?): instead of developing an algorithm to traverse the tree and render elements, it defines reusable components (AngularJS Directives) and includes the \ac{XML} files in the appropriate place in the \ac{DOM}. 
The browser already traverses the tree to render the page and there is no need to do it manually.
Normally a browser ignores an element that doesn't belong to the \ac{HTML} specification (e.g. \lstinline$<fl:ui fl:type="base-button"></fl:ui>$)
With AngularJS, the browser runs the behaviour defined in the reusable component.

\paragraph{Building Blocks} There are several key components in AngularJS to build the application.

\begin{itemize}
    \item \textbf{Controller}: a function that binds the view with the model. It typically assigns objects to the \$scope variable to expose them to the template.
    \item \textbf{Directive}: a construct to extend HTML with custom attributes and elements. It defines the template of the reusable component, the behaviour, the attributes, etc. For instance, the directive \texttt{flBaseButton} states that the node \lstinline$<fl:ui fl:type="base-button">$ in the \ac{DOM} tree should be transformed into a simple \texttt{button} using the theme template \texttt{baseButton.xml}. 
    \item \textbf{Service}: Singleton that encapsulates reusable business logic independent of views. For instance, a service to handle the configuration of the application. They can be injected in controllers, directives or other services.
    \item \textbf{Filter}: a function that formats the value of an expression for display to the user. For instance, a filter to display a Number with currency format.
    \item \textbf{Module}: These building blocks are grouped in Modules. They can have dependencies between them.
\end{itemize}

The framework provides all the necessary tools to use unit and end-to-end testing from the very beginning of the project.
Considering testing as equal in importance to application writing makes the code to be more robust, lowers the cost of maintenance and helps to have a better internal design.
\begin{itemize}
    \item \textbf{Jasmine} is a behaviour-driven development framework for testing JavaScript code. It does not depend on any other framework and does not require a \ac{DOM}. It provides a simple, self-descriptive (FIXME language!) syntax to write test suites.
    \item \textbf{Angular Mocks}: there are stub objects ready to load in tests (e.g. \texttt{\$httpBackend} mocks \ac{HTTP} calls)
    \item \textbf{Karma} is a test runner to automate the execution of the test suites. 
\end{itemize}
    
\paragraph{Compile-Link} To make directives possible Angular has a compiler.
In this context, compiling means attaching event listeners to the \ac{HTML} to make it interactive.
The compiler traverses the \ac{DOM} tree in two phases:
Firstly it looks for tags that have directives associated (e.g. \lstinline$<fl:ui fl:type="base-button">$ or even native \ac{HTML} elements \lstinline$<a>$).
Secondly it binds the model to the view.
The compiler allows developers to attach behaviour to any \ac{HTML} element or attribute and even create new HTML elements or attributes with custom behaviour.
Angular calls these behaviour extensions directives.

The order of execution is:

\lstinputlisting[language=xml, caption={Order of execution of directives}]{src/example-order-directives.xml}

\lstinputlisting[language=bash, caption={Result of execution of directives}]{src/result-order-directives.text}

The role of these functions is:
\begin{itemize}
\item \textbf{Directive Controller}: similar to regular controllers but accessible from other directives. 
\item \textbf{Compile}: finds new directives and runs their compile function. Modifications to the \ac{DOM} before applying the template can be done here.
\item \textbf{Link}: binds data to the view. Modifications to the final \ac{DOM} are safe to do here.
\end{itemize}

\paragraph{Directive} At a high level, directives are markers on a \ac{DOM} element (such as an attribute, element name, \ac{CSS} class or a comment) that tell Angular's \ac{HTML} compiler to attach a specified behaviour to it or even replace it with another element.
The \ac{HTML} compiler finds elements that match directives. 
For example, for \lstinline$<div ng-controller="myCtrl">$, the element \texttt{div} matches the directive \texttt{ngController}.
An example in Flango Content Manager: when the browser finds \lstinline$<fl:width>150</fl:width>$ in the \ac{DOM}, the element \texttt{width} matches the directive \texttt{flWidth}.
The \texttt{flWidth} directive is restricted to elements (it matches \lstinline$<fl:width>150</fl:width>$ but not \lstinline$<div fl:width>150</div>$ because it is an attribute), and it has a custom \texttt{link} function that performs some computation.

    
\subsection{HTML5}
maybe not useful. maybe just html

\subsection{SASS}
Writing plain \ac{CSS} can be tedious and error-prone.
SASS stands for Syntactically Awesome CSS and is a pre-processor with syntax advancements that add features to \ac{CSS}.
Sass is an extension of \ac{CSS}3, adding nested rules, variables, mixins, selector inheritance, and more.
It is then translated into well-formated, standard \ac{CSS} using the command line tool.
This makes reusing and extending \ac{CSS} easier.
SASS has two syntaxes. This project uses the newest one, known as \ac{SCSS} (Sassy CSS).

A key feature in this project is the \lstinline$@extend$ directive: it tells \ac{SASS} that one selector should inherit styles of another selector.
Example: the style \texttt{base-button} has a grey background. The style \texttt{button} sets the size of the element to $100 x 50 px$.
Because all \texttt{base-button}s are \texttt{button}s, the first should inherit the style from the second instead of replicating it, like one would do with \ac{OOD}.
With \ac{HTML} this would be written \lstinline$<div class="base-button button" />$.
With SASS one can write \lstinline$.base-button { @extend .button }$ and keep \ac{HTML} cleaner: \lstinline$<div class="base-button" />$

SASS variables and mixins make it easier to scaffold (FIXME LANGUAGE!) themes for Flango Content Manager and have consistency in the visual design (e.g. all themes can have palettes of the same size).

\subsection{Robot Web Tools}
Robot Web Tools is a collection of open-source modules and tools for building web-based robot applications.
It provides 3 core libraries to communicate with \ac{ROS} on the robot over rosbridge's WebSocket server: roslibjs, ros2js, and ros3djs.
This project uses roslibjs to subscribe and publish to Topics.

\section{Architecture}
context: comm with rob behaviour and rostopics (SOA).
MVC. client-side. JSON to talk to an API. xml files as angularjs partials, hacks to make it work (routes defined manually, one controller for all of them, dirty entities). scopes and their specific use here (compare to regular use). what about MVVM?

common patterns:
dependency injection and angularJS (and literature: fowler)

\subsection{Context}
Flango \cm is a piece in the robot.
\ac{ROS} is a framework for robot software development that provides operating system-like functionality on a heterogeneous computer cluster. 
It was originally developed in 2007 as part of the Stanford AI Robot (STAIR) project with the goal of providing an architectural framework supporting modular, tool-based development for robotic software.
It has a loosely coupled architecture with nodes, messages, topics and services, similar to \ac{SOA}.

DIAGRAM HERE: rosmaster (service registry), services, topics

Nodes are processes that perform computation, a "software module". 
Nodes communicate with each other by publishing/subscribing with two protocols:
\begin{itemize}
\item Topics: asynchronous. message passing (publish/subscribe). Typed by a \ac{ROS} Message
\item Services: synchronous. \ac{RPC} (pairs of request/response messages). Typed by a \ac{ROS} Service
\end{itemize}

Messages are strictly typed data structures . There are some available by default, like \texttt{std\_msgs/String} and other primitive types.
To find service in this peer-to-peer topology, there is a lookup mecanism: \emph{rosmaster} \fref{fig:design-ros-topics} and \fref{fig:design-ros-services}.



http://www.willowgarage.com/sites/default/files/icraoss09-ROS.pdf

The robot has two parts: robotBehaviour and Stacks.
Part of the code of the robot (robotBehaviour) does not follow the \ac{ROS} workflow but still uses Topics to communicate with the Stacks, the part of the project that does use \ac{ROS}.
In Stacks there are Servers and ActionServers that provide Services.
Flango is a component in this system that communicates with robotBehaviour using \ac{ROS} Topics and two types of messages.
It is not designed strictly as a service to handle synchronous requests but it is able to use Topics to have asynchronous requests and provide feedback, like ActionServers.
A typical use of a \ac{ROS} Topic is setting the language of the \cm or sending an action to robotBehaviour (e.g. shake hands, say a sentence).
robotBehaviour is not a \ac{ROS} service and therefore it can not handle request/responses like other components in the system.
Topics are the only way to communicate with it.


\begin{figure}[htb]
    \centering
    \includegraphics{figures/design/ros-architecture-topics.pdf}
    \caption{High-level view of the ROS Architecture (Topics)}
    \label{fig:design-ros-topics}
\end{figure}

\begin{figure}[htb]
    \centering
    \includegraphics{figures/design/ros-architecture-services.pdf}
    \caption{High-level view of the ROS Architecture (Services)}
    \label{fig:design-ros-services}
\end{figure}

FIXME diagrams ROS-flango-robot-robotbehaviour etc go here? in specs  just include the description of what the system does.

ROS i SOA.
robotbehaviour
flango as a (bad) service.



\subsection{MVC}
\ac{MVC} is a decoupled architecture with a strong separation of responsibilities (\fref{fig:mvc-overview}).
\begin{itemize}
    \item \textbf{Model} (application state). Maintains application state and notifies dependent views and controllers when changes occur (with the observer pattern)
    \item \textbf{View} (output) queries the model to print [parts of] it, listens for changes in the model
    \item \textbf{Controller} (input) Listens for input and tells the model or the view to change accordingly
\end{itemize}

It is possible to have multiple views and controllers for the same model and they can be reused for other models.

Angular applications take the most of the framework when they are designed with a \ac{MVC} architecture.
A typical use case in a \ac{MVC} application might be:
\begin{itemize}
    \item Model: [orange, apple, pineapple, coconut]
    \item View: displays a list of 2 random pieces of fruit
    \item Controller: logic that decides to fetch two pieces of fruit
\end{itemize}

Flango \cm does not have a \ac{GUI} or a set of predefined and stable use cases.
This changes for every contents application.
The system only knows the use cases after loading the contents application.
There can not be controllers for application-specific use cases and the view is created dynamically from the model.

\begin{itemize}
    \item \textbf{Model}: screens definitions, entities, configuration... stored in the backend
    \item \textbf{View}: built dynamically from the model. The application loads screens as the user browses to \ac{URL}s and transforms them to \ac{HTML} so that they can be displayed in the browser.
    \item \textbf{Controller}: Typically, controllers in Angular manage the \texttt{\$scope} and expose behaviour to the View. This application has some generic (as opposed to application-specific) ones. For example: an instance of \texttt{ActionCtrl} for each button, a \texttt{ROSBridgeCtrl} to respond to requests from ROS Bridge, etc. Directives also have a special type of controllers: Directive Controllers are defined within the context of one directive but they can be injected into other directives to facilitate inter-directive communication. For example, a controller in the \texttt{flUi} directive manages its properties (\texttt{x}, \texttt{y}, \texttt{width}, \texttt{height}, \texttt{caption}...). \texttt{flWidth}, \texttt{flX}, and other directives use the controller in \texttt{flUi}.
\end{itemize}

Angular uses an \ac{MVC} pattern with two-way data binding \fref{fig:mvc-with-observer}: changes in the view are reflected to the model immediately and viceversa in order to use the model as a single source of truth.
Controllers use the \texttt{\$scope} to expose values and behaviour to the view: they update the object that is used in the view.
The \texttt{scope} is an object that refers to the application model.
Informally, it is the glue between the controller and the view.
FIXME: SURE? Controllers are completely separated from the view and unaware of it: they just expose values but do not manipulate the \ac{DOM} or read it in any way to make testing easier.

\begin{figure}[htb]
    \centering
    \includegraphics{figures/design-patterns-mvc-1.pdf}
    \caption{MVC overview}
    \label{fig:mvc-overview}
\end{figure}

\begin{figure}[htb]
    \centering
    \includegraphics{figures/design-patterns-mvc-2.pdf}
    \caption{MVC with observer pattern}
    \label{fig:mvc-with-observer}
\end{figure}

\subsection{Common Patterns in the project}
DI, inversion of dependency, reveal, factory, async, fowler... hints of the remote faÃ§ade and SOAÂ¿?

This subsection is a high-level description of the most relevant software patterns in the project.

\paragraph{Constraints}
FIXME this section sucks 
%Flango Content Manager has  been designed taking into account the guidelines of \ac{GRASP} and the five basic principles of \ac{SOLID}.
The project follows object-oriented design adapted to the constraints induced by the technology and the requirements of the project.

FIXME improve this:
\begin{itemize}
    \item The \textbf{Angular Framework} is an approach to Web Components but components are not fully reusable. Moreover, most of the cl
    \item  Legacy \ac{XML}. The contents application uses \ac{XML} to define screens, templates, components, etc. The vocabulary and grammar of this \ac{XML} was designed having Adobe Flash and imperative programming in mind. While imperative programming is great for business logic, Angular prefers declarative programming for the view. 
%    \item This project is not a traditional \ac{CRUD} application. The model is a set of screens and 
\end{itemize}

 FIXME these are horrible paragraphs:
\paragraph{\ac{GRASP}} The patterns used in \ac{GRASP} are: Controller, Creator, Indirection, Information Expert, High Cohesion, Low Coupling, Polymorphism, Protected Variations, and Pure Fabrication. 
Angular enforces a strict separation of concerns between components and together with \ac{TDD} and unit testing, it helps keeping components loosely coupled.
The framework provides an easy way to create Controllers, non-user interface objects responsible for receiving and handling events.
They are mediators between the model and the view (indirection pattern). 
For example, $ActionCtrl$ for buttons receive events from the \ac{UI} and delegate the action to the corresponding class.
New elements of the framework, like Services or Directives, are created using a factory function.
FIXME However, the model are the screens and instead of creating an object from an \ac{XML} file the system just appends it to the \ac{DOM} and defines the behaviour in Directives, the software hardly ever has to create instances of objects explicitly.
FIXME should this be here?: The model is stable during the execution of the application. That is, new instances of classes of the model can not be created. 
New instances of classes are hardly ever created because the model is stable during the execution of the application. 
Changes are not made persistent. 
The application retrieves the model, renders it and lets the user interact with the contents in the touchscreen.

\paragraph{\ac{SOLID}} Five basic principles in software design are present in this project.
Classes have a single responsibility (e.g. Configuration for the \texttt{palSettings}, or managing properties of \ac{UI} elements with \texttt{palProperties}). 
FIXME: This principle works well with unit testing.


\paragraph{Dependency Injection and Service Locator} 
After applying the Creator Pattern (\ac{GRASP}) class \texttt{A} creates objects of dependant class \texttt{B}.
FIXME: sure? Managing dependencies correctly is a good way of applying other principles, like the Open-Closed.
One of the \ac{SOLID} principles, inversion of control, states that one should "Depend upon Abstractions. Do not depend upon concretions."
Dependency Injection is one of the implementations of this principle.

\cite{Fowler}

In general there are 3 ways an object can use another one:
\begin{enumerate}
	\item With a \texttt{new} operator
	\item Using global variables
	\item Pass in the dependency to where it is needed
\end{enumerate}

FIXME: take this code out and move it to the implementation chapter. let's use UML here.
A --creates--> B, vs. A --> servicelocator --> B

\lstinputlisting[language=javascript, caption={Hard-coded dependencies}]{src/design-di-1.js}

\lstinputlisting[language=javascript, caption={Passing on the reference (without service locator)}]{src/design-di-handling-dependency-to-component.js}

In LISTING 1 dependencies are hard-coded.
In LISTING 2 MasterGreater is not concerned with locating the \texttt{greeter} dependency, it is simply handed the \texttt{greeter} at runtime.
This is desirable, but it puts the responsibility of getting hold of the dependency on the code that constructs \texttt{MasterGreater}.


\textbf{Inversion of control} means that objects do not create other objects on which they rely to do their work.
They get the dependencies from an outside source (e.g. an \ac{XML} configuration file).
\textbf{Dependency Injection} means that this is done in a transparent way for the object.
The dependency is supplied to the software component.

The framework encourages the use of this pattern in all components. 
More specifically, the framework uses a Service Locator \fref{fig:design-service-locator} (called \texttt{injector}) to manage the responsibility of dependency creation.
Thus, services can be used in controllers and directives by their name.
The client class does not need to know the concrete implementation of the service. 
With this principle it is easy to mock classes for unit testing and change components in general.
A particular implementation of this principle is in the wrapper for roslibjs: the service \texttt{palROSBridge} in the application is made injectable and provides callbacks to allow a decoupled desing. FIXME LANGUAGE.

With AngularJS, injectable components are created with a factory and are made available using a global injector.
They can be injected just by using their name.

\begin{figure}[htb]
    \centering
    \includegraphics{figures/design-patterns-servicelocator.pdf}
    \caption{Service Locator}
    \label{fig:design-service-locator}
\end{figure}

\lstinputlisting[language=javascript, caption={Injecting services in a controller}]{src/design-di-injection.js}

They can be obtained manually with the \texttt{\$injector}

\lstinputlisting[language=javascript, caption={Manual injection (e.g. in a test)}]{src/design-di-manual-injection.js}

\paragraph{Factory} Directives, controllers, services... are registered on modules. 
The \texttt{module.directive} \ac{API} registers them. 
It takes a normalised name and a factory function (\ref{fig:design-patterns-factory}) that returns an object with the fields that can be exposed to classes that use it.
For example, a Directive Definition Object or a Service.

\begin{figure}[htb]
    \centering
    \includegraphics{figures/design-patterns-factory.pdf}
    \caption{Factory Method}
    \label{fig:design-patterns-factory0}
\end{figure}

\lstinputlisting[language=javascript, caption={Example of Factory}]{src/design-di-factory.js}




\paragraph{Revealing Module} \cite{Osmani:2012} Modules typically help in having the units of code for a project separated.
JavaScript does not support the concept of classes but it does support special constructor functions that work with objects. 
The $new$ keyword used in a call to a constructor function makes JavaScript instantiate the new object with members defined by that function.
Modules are a way to emulate the concept of classes.
There are several options to implement them. 
This project uses object literal notation (CROSS REF JAVASCRIPT)
The module pattern encapsulates privacy, state and organisation using closures (CROSS REF JAVASCRIPT)
Only a public \ac{API} is returned, keeping everything else hidden within the closure private.
With the Revealing Module Pattern the code of the module is simplified: all variables and functions are defined in the private scope and returns an anonymous object with pointers to the private properties that should be revealed.
FIXME CROSS REF factory code example  + annotation "compare to writing the code of the function right there"

\paragraph{Remote Facade} FIXME: sure? do I have a remote facade in the app, in a controller? rosbridgectrl?

\paragraph{Command} 
Sometimes requests are issued to objects without knowing anything about the operation being requested or the receiver.
The command pattern is a behavioural design pattern in which an object is used to represent all the information needed to call a method at a later time. 
It lets objects make requests of unspecified application objects by turning the request itself into an object.
This object can be stored and passed around like other objects \cite{GoF:1995}.
Other names are \textbf{Transaction} or \textbf{Action Pattern}  

\fref{fig:design-command-general} shows the class diagram for a traditional object-oriented programming language.
With JavaScript there are no abstract classes.
The approach that Osmani proposes is having only concrete classes with a common \texttt{execute()} method \cite{Osmani:2012} CROSS REF CODE EXAMPLE

FIXME include code design-command-1.js and design-command-2.js

With a simple controller (CROSSREF listing 1) one would call the methods in the object.
while this is correct, at the time the \ac{GUI} is built the \texttt{UI Component} does not know about the operations being requested.
For example, there is no way to define the behaviour for a \texttt{UI Component :: Button} click handler.
Only the contents application knows it.
By adding an \texttt{execute} method to \texttt{ActionCtrl}, used in \texttt{UI Components} that accept the tag \texttt{onclick} and \texttt{action}, methods can be called without knowing them CROSS REF listing 2

\begin{figure}[htb]
    \centering
    \includegraphics{figures/design-patterns-command-1.pdf}
    \caption{design patterns command 1}
    \label{fig:context-original}
\end{figure}

\begin{figure}[htb]
    \centering
    \includegraphics{figures/design-patterns-command-flango.pdf}
    \caption{design patterns command flango}
    \label{fig:context-original}
\end{figure}

\subsection{Orientation to Web Components}
Web Components is a set of specifications that let web developers use \ac{HTML}, \ac{CSS} and JavaScript to build widgets that can be reused easily and reliably.
A web component consists of five pieces\cite{W3CComponents:2013}:
\begin{itemize}
    \item \textbf{Templates} define chunks of mark-up that are inert but can be activated for use later.
    \item \textbf{Decorators} apply templates based on CSS selectors to affect rich visual and behavioural changes to documents.
    \item \textbf{Custom Elements} let authors define their own elements, with new tag names and new script interfaces.
    \item \textbf{Shadow DOM}  encapsulates a DOM sub-tree for more reliable composition of user interface elements.
    \item \textbf{Imports} defines how templates, decorators and custom elements are packaged and loaded as a resource.
\end{itemize}

At the time of developing this project, the specification of web components is still a work in progress.
The technology, however, seems to fit in the needs of the project.
There are 2 well-known initiatives that implement an approach to web components: \textbf{Google Polymer} and \textbf{Google AngularJS}.

\paragraph{Polymer} Polymer is a framework that aims to use Web Components. 
It's based on Custom Elements, i.e. everything is a component.
With Polymer developers can compose and encapsulate bits of HTML that can be used in any other templating system or framework.
It uses \ac{HTML} and the \ac{DOM} \acp{API} to separate the view (\ac{DOM}) from the model. 
Updates to the model are reflected in the \ac{DOM} and user input in the view is immediately propagated to the model:: fast two-way data binding.

Polymer is in pre-alpha stage and can not be used in a stable project.
Angular, the framework of choice for this project, has features close to web components: it has declarative templates (in directives) that can be applied for elements, attributes, comments or classes (like Web Components decorators).
Directives are custom elements: behaviour can be placed in a directive controller, in a compile or in a link function.
Templates are usually \ac{HTML}, although it is not shadow \ac{DOM}.
Units of code can be grouped in modules, services, etc and be reused.

\FloatBarrier

\section{Static View}
the model, the view and the controllers. angualar modules, services, filters, controllers...
talk about the data model and \$rootScope ? talk about properties

un diagrama:
moduls, serveis, controladors, etc. 

\subsection{Class Diagram}
Explanation about JS not having classes but just instances...

% ********** CLASS DIAGRAM ********
\begin{figure}[htb]
    \centering
    \includegraphics{figures/design-class-ui.pdf}
    \caption{Class Diagram -- UI}
    \label{fig:class-ui}
\end{figure}

\begin{sidewaysfigure}[htb]
    \centering
    \includegraphics{figures/design-class-uicomponent.pdf}
    \caption{Class Diagram -- UI Component}
    \label{fig:class-uicomponent}
\end{sidewaysfigure}

\begin{sidewaysfigure}[htb]
    \centering
    \includegraphics{figures/design-class-themecomponents.pdf}
    \caption{Class Diagram -- UI Theme Component}
    \label{fig:class-themecomponent}
\end{sidewaysfigure}

\begin{figure}[htb]
    \centering
    \includegraphics{figures/design-class-services.pdf}
    \caption{Class Diagram -- UI services}
    \label{fig:class-services}
\end{figure}

\begin{figure}[htb]
    \centering
    \includegraphics{figures/design-class-ngfactory.pdf}
    \caption{Class Diagram -- angular factory}
    \label{fig:class-ngfactory}
\end{figure}

\begin{figure}[htb]
    \centering
    \includegraphics{figures/design-class-controllers.pdf}
    \caption{Class Diagram -- angular controllers}
    \label{fig:class-controllers}
\end{figure}

\begin{figure}[htb]
    \centering
    \includegraphics{figures/design-class-action.pdf}
    \caption{Class Diagram -- ui action}
    \label{fig:class-action}
\end{figure}


% ********** PACKAGE DIAGRAM ********
\FloatBarrier
\subsection{Packages Diagrams}

\begin{figure}[htb]
    \centering
    \includegraphics{figures/design-package-controllers.pdf}
    \caption{Packages Diagram -- controllers}
    \label{fig:pkg-controllers}
\end{figure}

\begin{figure}[htb]
    \centering
    \includegraphics{figures/design-package-reemi.pdf}
    \caption{Packages Diagram -- application}
    \label{fig:pkg-reemi}
\end{figure}

\begin{figure}[htb]
    \centering
    \includegraphics{figures/design-package-services.pdf}
    \caption{Packages Diagram -- services}
    \label{fig:pkg-services}
\end{figure}

\begin{figure}[htb]
    \centering
    \includegraphics{figures/design-package-uicomponents.pdf}
    \caption{Packages Diagram -- UI components}
    \label{fig:pkg-uicomponents}
\end{figure}

\begin{figure}[htb]
    \centering
    \includegraphics{figures/design-package-ui.pdf}
    \caption{Packages Diagram -- UI}
    \label{fig:pkg-ui}
\end{figure}

\begin{figure}[htb]
    \centering
    \includegraphics{figures/design-package-uithemecomponents.pdf}
    \caption{Packages Diagram -- UI theme components}
    \label{fig:pkg-themecomponents}
\end{figure}

\FloatBarrier

\section{Dynamic view}
the flow: user creates an application, [robot sync], my app reads it and generates HTML output.

specific flow of an app. bootstrap, the compile-link phase, push classes, push styles, get url params, etc.
examples of using the properties, generating the settings, fetching things from the server, rostopics...

show patterns!

This section contains a detailed description of the most relevant operations.
They are grouped in XXX categories: boot-strap and configuration, handling properties and transformation to \ac{HTML}, pop-ups, internal navigation and communication with ROS Bridge.
It always works the same way: writing the appropriate behaviour in directives (controller, compile and link functions) and injecting the required services following the flow that Angular needs.

\subsection{Overview}
compile-link-ctrl
seq diagram: detecting a directive, etc. general example with "book" "fruit" etc

\subsection{Boot-strap and Configuration}
FIXME Notes: description -- bootup (register modules, fetch config, querystring, goto init, subscribe)

Some key operations are done during the boot-strap process of Angular, like registering modules, setting dependencies and the default routes (e.g. \texttt{http:// ... /app/index.html\#/products-view/14/detail-view}.
The Flango \cm also fetches de configuration from the backend and builds the local object that represents it.
Figures \fref{fig:design-seqdia-bootstrap-1}, \fref{fig:design-seqdia-bootstrap-2} and \fref{fig:design-seqdia-bootstrap-3}, show the bootstrap of the program.

\begin{figure}[htb]
    \centering
    \includegraphics{figures/design/seqdia/bootstrap-1.pdf}
    \caption{Bootstrap 1}
    \label{fig:design-seqdia-bootstrap-1}
\end{figure}

\begin{figure}[htb]
    \centering
    \includegraphics{figures/design/seqdia/bootstrap-2.pdf}
    \caption{Bootstrap 2}
    \label{fig:design-seqdia-bootstrap-2}
\end{figure}

\begin{figure}[htb]
    \centering
    \includegraphics{figures/design/seqdia/bootstrap-3.pdf}
    \caption{Bootstrap 3}
    \label{fig:design-seqdia-bootstrap-3}
\end{figure}

The configuration is encapsulated in the \texttt{palSettings} angular service which, like all services in Angular, is a singleton.
This service is created with a factory: when a new instance of palSettings is to be created, it runs some code that prepares an object to return, the instance itself.
It is instantiated and initialiased the first time it is called.
The configuration object is created during the bootstrap.
It calls $palSettings.init(queryString)$ \fref{fig:design-seqdia-palSettings-init}.
This method fetches the configuration from the backend using an asynchronous call (\fref{fig:design-seqdia-palSettings-getConfig}) which, in turn, delegates to other internal operations.
To avoid errors, the system uses \emph{deferred promises}: the \texttt{init} method returns an object of this type immediately and it receives a notification when all asynchronous calls have been completed, that is, when the configuration object is ready to be used in the application.

The configuration object has three parts: the generic configuration (paths, \ac{API} endpoint, etc) \fref{fig:design-seqdia-palSettings-getGenericConfig}, the application specific configuration {fig:design-seqdia-palSettings-getApplicationConfig} (available languages, available themes, default language, etc) and the structure \fref{fig:design-seqdia-palSettings-getStructure} (a graph that matches screens with \ac{URI}.
It degrades gradually: it first tries to fetch the real application, if it fails attempts to fetch the default application \fref{fig:design-seqdia-palSettings-defaultApplicationConfig}, if this is not possible, it obtains the static application shipped with the program (See \texttt{errorCallback} in \fref{fig:design-seqdia-palSettings-defaultApplicationConfig}).

\begin{figure}[htb]
    \centering
    \includegraphics{figures/design/seqdia/palSettings-init.pdf}
    \caption{init()}
    \label{fig:design-seqdia-palSettings-init}
\end{figure}


\begin{figure}[htb]
    \centering
    \includegraphics{figures/design/seqdia/palSettings-getConfig.pdf}
    \caption{getConfig()}
    \label{fig:design-seqdia-palSettings-getConfig}
\end{figure}

\begin{figure}[htb]
    \centering
    \includegraphics{figures/design/seqdia/palSettings-getGenericConfig.pdf}
    \caption{getGenericConfig()}
    \label{fig:design-seqdia-palSettings-getGenericConfig}
\end{figure}

\begin{figure}[htb]
    \centering
    \includegraphics{figures/design/seqdia/palSettings-getApplicationConfig.pdf}
    \caption{getApplicationConfig()}
    \label{fig:design-seqdia-palSettings-getApplicationConfig}
\end{figure}


\begin{figure}[htb]
    \centering
    \includegraphics{figures/design/seqdia/palSettings-getStructure.pdf}
    \caption{getStructure()}
    \label{fig:design-seqdia-palSettings-getStructure}
\end{figure}

\begin{sidewaysfigure}[htb]
    \centering
    \includegraphics{figures/design/seqdia/palSettings-defaultApplicationConfig.pdf}
    \caption{defaultApplicationConfig()}
    \label{fig:design-seqdia-palSettings-defaultApplicationConfig}
\end{sidewaysfigure}

\FloatBarrier

\subsection{Properties management and transformation to \ac{HTML}}
descr with example (transform a  book into...)

interpretacio de tags. fl:ui type=.. --> fl {type} per separar

herÃ¨ncia de ui components (un basebutton s'implementa amb...)

plantilles dels temes

Browsers can only parse \ac{HTML} nodes.
When the parser finds an \ac{XML} node, it prints the inner text node because \ac{HTML} also has text nodes.
With Angular \ac{XML} nodes can have behaviour: it teaches the browser new syntax.
For example, \lstinline$<fl:ui fl:base-button fl:x="100" fl:width="90"></ui>$ triggers the directive \lstinline$flBaseButton$, which encapsulates the behaviour to transform it to \ac{HTML}: \lstinline$<a href="..."><div>text</div></a>$.

To expose values to the view, Angular attaches an object \texttt{\$scope} to all directives  \fref{fig:design-properties-management}.
A scope can be \textbf{isolated}, \textbf{prototypically inherited} from the parent, or \textbf{shared} with other directives of the same type.
This project uses the scope to encapsulate the properties extracted or inferred from the \ac{XML} node.
Thus, any element \lstinline$<fl:ui>$ or concrete types \lstinline$base-button$, \lstinline$back-button$, etc has a \texttt{scope} object attached that contains all the necessary data to render an \ac{HTML} node.
Scopes are also watched to provide two-way data binding with controllers (see CROSS REF observer/mvc)

\begin{figure}[h]
    \centering
    \includegraphics{figures/design/properties-management.pdf}
    \caption{Scope object attached to a node}
    \label{fig:design-properties-management}
\end{figure}

\lstinputlisting[language=xml, caption={Original XML BaseButton}, label="design-real-xml-button"]{src/from-xml-to-html-1.xml}
\lstinputlisting[language=JavaScript, caption={Properties object}, label="design-scope-properties"]{src/from-xml-to-html-properties.js}

\begin{figure}
    \centering
    \includegraphics{figures/design/from-xml-to-html-3.pdf}
    \caption{Transformation from XML to HTML and styles management}
    \label{fig:design-xml-to-html-3}
\end{figure}


Directives can be \textbf{restricted} to \textbf{Element}, \textbf{Attribute}, \textbf{Class} or \textbf{coMment} \fref{fig:class-ngfactory}.
Flango \cm is designed to adapt to this syntax and to decouple and reuse elements as much as possible.
All UI Components have the tag \lstinline$<fl:ui>$ and an attribute \lstinline$fl:type$ that defines the concrete type.
Instead of having all behaviour in one directive \texttt{fl:ui} (restricted to Element), it uses \texttt{flUi} to rewrite the \ac{DOM}: \lstinline$<fl:ui fl:type="base-button"></ui>$ becomes \lstinline$<fl:ui base-button></ui>$, where \texttt{base-button} is an attribute of the element \texttt{fl:ui}.
There is a directive \texttt{flBaseButton} (restricted to Attribute) that encapsulates the behaviour of this tag.
Likewise, it initialises the properties object for this \texttt{ui} element and stores the type that will be later used as a value for the \texttt{class} attribute in the \ac{HTML} element.
The stylesheet of the theme defines the inheritance of styles: a base-button is implemented with a button and, therefore, inherits all properties of the class \texttt{button}.

Figure \fref{fig:design-xml-to-html-3} shows the implementation of the transformation the base button in the \ac{XML} screen (\ref{design-real-xml-button}) and the use of the properties object in the scope (\ref{fig:design-xml-to-html-3}).

The algorithm to decide the properties for an object and draw it with \ac{HTML} goes with the flow of the framework:
\begin{enumerate}
	\item With directive \texttt{flUi}: Create an attribute with the value of the \texttt{type} attribute \fref{fig:design-seqdia-ui-compile}. Initialise the properties object in the controller \fref{fig:design-seqdia-ui-controller} The framework compiles and links the rest of the code (e.g. the \texttt{link()} function in inner \texttt{width} tags to read values of inner tags (\fref{fig:design-seqdia-width-link}))
	\item With directive \texttt{flUi} link function (\fref{fig:design-seqdia-ui-link}), read in-line attributes. Because it reads everything recursively, this is the last function to run. Properties are only set if they have not been set yet: inner tags (more specific) have higher priority than in-line attributes. Recompile the directive to make angular find it. 
	\item With the new directive (e.g. \texttt{flBaseButton}), run component-specific behaviour. \texttt{flUi} does not have a \texttt{type} attribute anymore and is ignored. Specific behaviour can be transforming it using a template \fref{fig:design-seqdia-basebutton-link}. Recompile (e.g. the template might, and normally has, tags that can trigger angular directives).
	\item Eventually reach a base component and run component-specific behaviour, e.g. create \ac{HTML} nodes that can actually draw the UI Component.
\end{enumerate}

\begin{figure}[htb]
    \centering
    \includegraphics{figures/design/seqdia/ui-compile.pdf}
    \caption{flUi::compile}
    \label{fig:design-seqdia-ui-compile}
\end{figure}

\begin{figure}[htb]
    \centering
    \includegraphics{figures/design/seqdia/ui-controller.pdf}
    \caption{flUi::controller}
    \label{fig:design-seqdia-ui-controller}
\end{figure}

\begin{figure}[htb]
    \centering
    \includegraphics{figures/design/seqdia/width-link.pdf}
    \caption{flWidth::link}
    \label{fig:design-seqdia-width-link}
\end{figure}

\begin{figure}[htb]
    \centering
    \includegraphics{figures/design/seqdia/ui-link.pdf}
    \caption{flUi::link}
    \label{fig:design-seqdia-ui-link}
\end{figure}

\begin{figure}[htb]
    \centering
    \includegraphics{figures/design/seqdia/basebutton-link.pdf}
    \caption{flBaseButton::link}
    \label{fig:design-seqdia-basebutton-link}
\end{figure}

\lstinline$<fl:ui base-button></ui>$ eventually becomes \lstinline$<div class="base-button" style="..."><div class="caption">Hello World</caption></div>$. 
With this rewrite strategy the directive eventually outputs real \ac{HTML} that defines the structure of the UI Component and uses the style sheet.

All UI Components have an  \textbf{\ac{HTML} template} that defines their structure, a \textbf{\ac{CSS} class} that defines their style, \textbf{in-line \ac{CSS}} that defines their exclusive properties (e.g. position, size...) and they are binded to \textbf{\texttt{ActionCtrl}} to expose behaviour (e.g. on click).
\FloatBarrier

\paragraph{Inheritance and composition} UI Components can be composited: a \texttt{home-button} is implemented with a \texttt{base-button}, which in turn it is implemented with a \texttt{button}, that eventually becomes \ac{HTML}.
Each component can have defaults for properties.
For instance, if \texttt{base-button} has a \texttt{width} of 100px in the template, and a component that is implemented with \texttt{base-button} (e.g. \texttt{home-button}) does not define a different with, it sets \texttt{with} to 100 in the properties object.
This behaviour is achieved with the \texttt{compile} and \texttt{link} functions of directives.
Language-specific properties are decided the same way: it attempts to use current language properties, if they are not defined, it falls back to the default language.

\subsection{Actions execution}
Buttons and other UI Components, like images or QR Codes, respond to clicks.
\ac{XML} can define a list of actions to execute (e.g. set the language, open a popup, go to \ac{URI}...)
The controller ActionCtrl encapsulates the logic to process these commands.

\lstinputlisting[language=xml, caption={A list of actions}]{src/example-actions.xml}

\lstinputlisting[language=html, caption={Result button (snippet)}]{src/example-result-button.html}

To create the list of actions, when the component is clicked it runs \lstinline$executeActions()$, which has a list of actions to execute as a parameter using the command pattern.

\begin{figure}[htb]
    \centering
    \includegraphics{figures/design/seqdia/actionCtrl-executeActions.pdf}
    \caption{ActionCtrl::executeActions}
    \label{fig:design-seqdia-actionCtrl-executeActions}
\end{figure}

\begin{figure}[htb]
    \centering
    \includegraphics{figures/design/seqdia/actionCtrl-execute.pdf}
    \caption{ActionCtrl::execute}
    \label{fig:design-seqdia-actionCtrl-execute}
\end{figure}


\begin{figure}[htb]
    \centering
    \includegraphics{figures/design/seqdia/actionCtrl-goto.pdf}
    \caption{ActionCtrl::execute}
    \label{fig:design-seqdia-actionCtrl-goto}
\end{figure}

\FloatBarrier

\subsection{Pop-Ups}
description and use example

\subsection{Internal Navigation}
Angular has a navigation system based on the \acp{URL}.
The \$route service has a map that relates \acp{URL} with screens, \ac{HTML} files with directives.
On each location change, Angular looks up the destination \ac{URL} in the map to fetch the correct file.

Flango \cm composites screens with subscreens and decides the contents to show using the \ac{URL} \fref{fig:design-internal-navigation}.
e.g. the \ac{URL} \texttt{/main-view/animals-list} does not populate the subscreen \texttt{red-panda-details}

\begin{figure}[htb]
    \centering
    \includegraphics{figures/design/internal-navigation.pdf}
    \caption{Screens and subscreens for internal navigation}
    \label{fig:design-internal-navigation}
\end{figure}

The behaviour of subscreens is defined in the \texttt{subscreen} directive (\fref{fig:design-seqdia-subscreen-compile}).

Only after properties of the UI Component Subscreen have been set (and the corresponding \ac{HTML} element created), Angular includes the file of the subscreen.

\begin{sidewaysfigure}[htb]
    \centering
    \includegraphics{figures/design/seqdia/subscreen-compile.pdf}
    \caption{Subscreen::compile}
    \label{fig:design-seqdia-subscreen-compile}
\end{sidewaysfigure}

\FloatBarrier

\subsection{External Calls}
motivation, rosbridge

\subsection{Responding to requests from the robot}
service, topic, rosbridge, etc

\begin{figure}[htb]
    \centering
    \includegraphics{figures/design/seqdia/ROSBridgeCtrl-creation.pdf}
    \caption{ROSBridgeCtrl::instantiation and subscription to topic}
    \label{fig:design-seqdia-ROSBridgeCtrl-creation}
\end{figure}

\begin{sidewaysfigure}[htb]
    \centering
    \includegraphics{figures/design/seqdia/ROSBridgeCtrl-callback.pdf}
    \caption{ROSBridgeCtrl::Example callback function}
    \label{fig:design-seqdia-ROSBridgeCtrl-callback}
\end{sidewaysfigure}

\FloatBarrier

\section{Physical view}
This section presents a series of diagrams to illustrate the physical layout of the project: the nodes involved, the components in each node, and a clear separation of the Flango \cm and the environment.
The application is assembled in a Debian package and deployed to Basestation and the robot.
The control scripts of this package perform tasks like copying the files to the correct place (e.g. the public html folder of the web server), initialise data in the backend, etc.
The diagrams in this section show the system after the installation.

% ****** deployment *******
\begin{figure}[htb]
    \centering
    \includegraphics{figures/design-deployment-basestation.pdf}
    \caption{Deployment Diagram -- basestation}
    \label{fig:deploy-basestation}
\end{figure}

\begin{sidewaysfigure}[htb]
    \centering
    \includegraphics{figures/design-deployment-browser.pdf}
    \caption{Deployment Diagram -- browser}
    \label{fig:deploy-browser}
\end{sidewaysfigure}

\begin{figure}[htb]
    \centering
    \includegraphics{figures/design-deployment-mediacomputer.pdf}
    \caption{Deployment Diagram -- media computer}
    \label{fig:deploy-media}
\end{figure}

\begin{figure}[htb]
    \centering
    \includegraphics{figures/design-deployment-reem.pdf}
    \caption{Deployment Diagram -- reem}
    \label{fig:deploy-reem}
\end{figure}

\begin{figure}[htb]
    \centering
    \includegraphics{figures/design-deployment-webserver.pdf}
    \caption{Deployment Diagram -- webserver}
    \label{fig:deploy-webserver}
\end{figure}

\FloatBarrier

FIXME MAYBE ADD NETWORK DIAGRAM? VPN, ENCRIPTION? it's qutie simple