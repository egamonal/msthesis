\chapter{Design}
coming from previous chapter: Code Restructuring; Data Restructuring; Forward Engineering
    
    
explain the internal design of the new application.
internal design of the application. this should be the fun part.

This chapter describes the internal wiring of the application and the reasons that lead to this design.
It explains the programming languages, frameworks and most relevant libraries, 

\section{Technology}
angularJS (teach the browser new syntax), javascript, html5, Qt, QtBrowser and its limitations (JS engine vs chrome v8 or firefox's). tdd+jasmine

The project of this thesis, Flango Content Manager, is designed to work client side in a web browser.
The natural technology in this environment is JavaScript, HTML and CSS.
It uses the Google AngularJS framework with jQuery.
Angular \textit{teaches the browser new syntax}.
That is, instead of parsing the \ac{DOM} tree and building the \ac{GUI}, it defines the behaviour of new tags in \ac{HTML} documents that can be treated as regular \ac{HTML} nodes in the \ac{DOM}.
It interoperates with other systems built with a different technology: components in the robot use \ac{ROS} and the \flangobe has an \ac{API}. FIXME CROSS REF PHYISICAL DESIGN or CONTEXT



\subsection{JavaScript}
some hints. functional. scopes.
language, jquery, qr, swf

Object Literal Notation, constructors, closures, var scope, concept of classes



\subsection{AngularJS}
about the framework. directives, services, 
The framework enforces a very strict separation of responsibilities: DOM updates are abstracted away from model updates. 
Directives act as the layer that keeps these two aspects loosely coupled. One one hand, directives translate data into user interfaces; and, on the other hand, directives translate user interactions back into \$scope behaviors. FIXME Reword this

\paragraph{Overview} AngularJS is a framework for dynamic web applications.
\ac{HTML} was created to declare static documents. 
It needs libraries and frameworks to enable application development.
Angular lets developers use \ac{HTML} in the templates and extend the language syntax to express reusable components.
It \textit{teaches the browser new syntax} through a construct called Directive.
Features:
\begin{itemize}
    \item Tools to build \ac{CRUD} Applications: data-binding, basic templating directives, form validation, routing, deep-linking, reusable components, dependency injection.
    \item Tools to test: unit-testing, end-to-end testing, mocks.
\end{itemize}

Flango Content Manager reads \ac{XML} and renders it as \ac{HTML}.
There are two possible approaches: parsing the \ac{DOM} tree in the browser or teaching the browser new syntax.
This project uses the second (FIXME language: the latter?): instead of developing an algorithm to traverse the tree and render elements, it defines reusable components (AngularJS Directives) and includes the \ac{XML} files in the appropriate place in the \ac{DOM}. 
The browser already traverses the tree to render the page and there is no need to do it manually.
Normally a browser ignores an element that doesn't belong to the \ac{HTML} specification (e.g. \lstinline$<fl:ui fl:type="base-button"></ui>$)
With AngularJS, the browser runs the behaviour defined in the reusable component.

\paragraph{Building Blocks} There are several key components in AngularJS to build the application.

\begin{itemize}
    \item Controller: a function that binds the view with the model. It typically assigns objects to the \$scope variable to expose them to the template.
    \item Directive: a construct to extend HTML with custom attributes and elements. It defines the template of the reusable component, the behaviour, the attributes, etc. For instance, the directive $flBaseButton$ states that the node $<fl:ui fl:type="base-button">$ in the \ac{DOM} tree should be transformed into a simple $button$ using the theme template $baseButton.xml$. 
    \item Service: Singleton that encapsulates reusable business logic independent of views. For instance, a service to handle the configuration of the application. They can be injected in controllers, directives or other services.
    \item Filter: a function that formats the value of an expression for display to the user. For instance, a filter to display a Number with currency format.
    \item Module: These building blocks are grouped in Modules. They can have dependencies between them.
\end{itemize}

The framework provides all the necessary tools to use unit and end-to-end testing from the very beginning of the project.
Considering testing as equal in importance to application writing makes the code to be more robust, lowers the cost of maintenance and helps to have a better internal design.
\begin{itemize}
    \item Jasmine is a behavior-driven development framework for testing JavaScript code. It does not depend on any other framework and does not require a \ac{DOM}. It provides a simple, self-descriptive (FIXME language!) syntax to write test suites.
    \item Angular Mocks: there are stub objects ready to load in tests (e.g. \$httpBackend mocks \ac{HTTP} calls)
    \item Karma is a test runner to automate the execution of the test suites. 
\end{itemize}
    
\paragraph{Compile-Link} To make directives possible Angular has a compiler.
In this context, compiling means attaching event listeners to the \ac{HTML} to make it interactive.
The compiler traverses the \ac{DOM} tree in two phases:
Firstly it looks for tags that have directives associated (e.g. $<fl:ui fl:type="base-button">$ or even native \ac{HTML} elements $<a>$).
Secondly it binds the model to the view.
The compiler allows developers to attach behaviour to any \ac{HTML} element or attribute and even create new HTML elements or attributes with custom behaviour. Angular calls these behaviour extensions directives.

\paragraph{Directive} At a high level, directives are markers on a \ac{DOM} element (such as an attribute, element name, \ac{CSS} class or a comment) that tell Angular's \ac{HTML} compiler to attach a specified behaviour to it or even replace it with another element.
The \ac{HTML} compiler finds elements that match directives. 
For example, for $<div ng-controller="myCtrl">$, the element $div$ matches the directive $ngController$.
An example in Flango Content Manager: when the browser finds $<fl:width>150</fl:width>$ in the \ac{DOM}, the element $width$ matches the directive $flWidth$.
The $flWidth$ directive is restricted to elements (it matches $<fl:width>150</fl:width>$ but not $<div fl:width>150</div>$ because it is an attribute), and it has a custom $link$ function that performs some computation.

    
\subsection{HTML5}
maybe not useful. maybe just html

\subsection{SASS}
Writing plain \ac{CSS} can be tedious and error-prone.
SASS stands for Syntactically Awesome CSS and is a pre-processor with syntax advancements that add features to \ac{CSS}.
Sass is an extension of \ac{CSS}3, adding nested rules, variables, mixins, selector inheritance, and more.
It is then translated into well-formated, standard \ac{CSS} using the command line tool.
This makes reusing and extending \ac{CSS} easier.
SASS has two syntaxes. This project uses the newest one, known as \ac{SCSS} (Sassy CSS).

A key feature in this project is the "$@extend$" directive: it tells SASS that one selector should inherit styles of another selector.
Example: the style $base-button$ has a grey background. The style $button$ sets the size of the element to $100 x 50 px$.
Because all $base-button$s are $button$s, a $base-button$ should inherit the style from $button$ instead of replicating it, like one would do with \ac{OOD} in a programming language.
With \ac{HTML} this would be written $<div class="base-button button" />$.
With SASS one can write $.base-button { @extend .button }$ and keep \ac{HTML} cleaner: $<div class="base-button" />$

SASS variables and mixins make it easier to scaffold (FIXME LANGUAGE!) themes for Flango Content Manager and have consistency in the visual design (e.g. all themes can have palettes of the same size).

\subsection{Robot Web Tools}
Robot Web Tools is a collection of open-source modules and tools for building web-based robot applications.
It provides 3 core libraries to communicate with \ac{ROS} on the robot over rosbridge's WebSocket server: roslibjs, ros2js, and ros3djs.
This project uses roslibjs to subscribe and publish to Topics.

\section{Architecture}
context: comm with rob behaviour and rostopics (SOA).
MVC. client-side. JSON to talk to an API. xml files as angularjs partials, hacks to make it work (routes defined manually, one controller for all of them, dirty entities). scopes and their specific use here (compare to regular use). what about MVVM?

common patterns:
dependency injection and angularJS (and literature: fowler)

\subsection{Context}
Flango Content Manager is a piece in the robot.
\ac{ROS} is a framework for robot software development that provides operating system-like functionality on a heterogeneous computer cluster. 
It was originally developed in 2007 as part of the Stanford AI Robot (STAIR) project with the goal of providing an architectural framework supporting modular, tool-based development for robotic software.
It has a loosely coupled architecture with nodes, messages, topics and services, similar to \ac{SOA}.

DIAGRAM HERE: rosmaster (service registry), services, topics

Nodes are processes that perform computation, a "software module". 
Nodes communicate with Messages, strictly typed data structures . There are some available by default, like $std_msgs/String$ and other primitive types.
Nodes subscribe and publish to topics, identified by a name (string).
Services are pairs of request/response messages offered in a node designed for simple synchronous transactions.
FIXME add ActionServers???


http://www.willowgarage.com/sites/default/files/icraoss09-ROS.pdf

The robot has two parts: robotBehaviour and Stacks.
Part of the code of the robot (robotBehaviour) does not follow the \ac{ROS} workflow but still uses Topics to communicate with the Stacks, the part of the project that does use \ac{ROS}.
In Stacks there are Servers and ActionServers that provide Services.
Flango is a component in this system that communicates with robotBehaviour using \ac{ROS} Topics and two types of messages.
It is not designed strictly as a service to handle synchronous requests but it is able to use Topics to have asynchronous requests and provide feedback, like ActionServers.
A typical use of a \ac{ROS} Topic is setting the language of the Content Manager or sending an action to robotBehaviour (e.g. shake hands, say a sentence).
robotBehaviour is not a \ac{ROS} service and therefore it can not handle request/responses like other components in the system.
Topics are the only way to communicate with it.

OR MAYBE DIAGRAM HERE: rosmaster (service registry), services, topics, FLANGO

FIXME diagrams ROS-flango-robot-robotbehaviour etc go here? in specs  just include the description of what the system does.

ROS i SOA.
robotbehaviour
flango as a (bad) service.



\subsection{MVC}
\ac{MVC} is a decoupled architecture with a strong separation of responsibilities.
\begin{itemize}
    \item Model (application state). Maintains application state and notifies dependent views and controllers when changes occur (with the observer pattern)
    \item View (output) queries the model to print [parts of] it, listens for changes in the model
    \item Controller (input) Listens for input and tells the model or the view to change accordingly
\end{itemize}

It is possible to have multiple views and controllers for the same model and they can be reused for other models.

Angular applications take the most of the framework when they are designed with a \ac{MVC} architecture.
A typical use case in a \ac{MVC} application might be:
\begin{itemize}
    \item Model: [orange, apple, pineapple, coconut]
    \item View: displays a list of 2 random pieces of fruit
    \item Controller: logic that decides to fetch two pieces of fruit
\end{itemize}

Flango Content Manager does not have a \ac{GUI} or a set of predefined and stable use cases.
This changes for every contents application.
The system only knows the use cases after loading the contents application.
There can not be controllers for application-specific use cases and the view is created dynamically from the model.

\begin{itemize}
    \item Model: screens definitions, entities, configuration... stored in the backend
    \item View: built dynamically from the model. The application loads screens as the user browses to \ac{URL}s and transforms them to \ac{HTML} so that they can be displayed in the browser.
    \item Controller: Typically, controllers in Angular manage the $\$scope$ and expose behaviour to the View. This application has some generic (as opposed to application-specific) ones. For example: an instance of $ActionCtrl$ for each button, a $ROSBridgeCtrl$ to respond to requests from ROS Bridge, etc. Directives also have a special type of controllers: Directive Controllers are defined within the context of one directive but they can be injected into other directives to facilitate inter-directive communication. For example, a controller in the $flUi$ directive manages its properties (x, y, width, height, caption...). $flWidth$, $flX$, and other directives use the controller in $flUi$.
\end{itemize}

FIXME: DIAGRAM HERE

Angular uses an \ac{MVC} pattern like the one in \fref{fig:design-mvc}.
It has two-way data binding: changes in the view are reflected to the model immediately and viceversa in order to use the model as a single source of truth.
Controllers use the \$scope to expose values and behaviour to the view: they update the object that is used in the view.
The \texttt{scope} is an object that refers to the application model.
Informally, it is the glue between the controller and the view.
FIXME: SURE? Controllers are completely separated from the view and unaware of it: they just expose values but do not manipulate the \ac{DOM} or read it in any way to make testing easier.

explain typical mvc app
explain whats model, controllers and view in flango
controllers "use services" 

\subsection{Common Patterns in the project}
DI, inversion of dependency, reveal, factory, async, fowler... hints of the remote façade and SOA¿?

This subsection is a high-level description of the most relevant software patterns in the project.

paragraphs for the patterns go here

\paragraph{Constraints}
FIXME this section sucks
%Flango Content Manager has  been designed taking into account the guidelines of \ac{GRASP} and the five basic principles of \ac{SOLID}.
The project follows object-oriented design adapted to the constraints induced by the technology and the requirements of the project.

FIXME improve this:
\begin{itemize}
    \item The \textbf{Angular Framework} is an approach to Web Components but components are not fully reusable. Moreover, most of the cl
    \item  Legacy \ac{XML}. The contents application uses \ac{XML} to define screens, templates, components, etc. The vocabulary and grammar of this \ac{XML} was designed having Adobe Flash and imperative programming in mind. While imperative programming is great for business logic, Angular prefers declarative programming for the view. 
%    \item This project is not a traditional \ac{CRUD} application. The model is a set of screens and 
\end{itemize}

% FIXME these are horrible paragraphs
\paragraph{\ac{GRASP}} The patterns used in \ac{GRASP} are: Controller, Creator, Indirection, Information Expert, High Cohesion, Low Coupling, Polymorphism, Protected Variations, and Pure Fabrication. 
Angular enforces a strict separation of concerns between components and together with \ac{TDD} and unit testing, it helps keeping components loosely coupled.
The framework provides an easy way to create Controllers, non-user interface objects responsible for receiving and handling events.
They are mediators between the model and the view (indirection pattern). 
For example, $ActionCtrl$ for buttons receive events from the \ac{UI} and delegate the action to the corresponding class.
New elements of the framework, like Services or Directives, are created using a factory function.
FIXME However, the model are the screens and instead of creating an object from an \ac{XML} file the system just appends it to the \ac{DOM} and defines the behaviour in Directives, the software hardly ever has to create instances of objects explicitly.
FIXME should this be here?: The model is stable during the execution of the application. That is, new instances of classes of the model can not be created. 
New instances of classes are hardly ever created because the model is stable during the execution of the application. 
Changes are not made persistent. 
The application retrieves the model, renders it and lets the user interact with the contents in the touchscreen.

\paragraph{\ac{SOLID}} Five basic principles in software design are present in this project.
Classes have a single responsibility (e.g. Configuration for the $palSettings$, or managing properties of \ac{UI} elements with $palProperties$). 
FIXME: This principle works well with unit testing.


\paragraph{Dependency Injection and Service Locator} 
After applying the Creator Pattern (\ac{GRASP}) class $A$ creates objects of dependant class $B$.
FIXME: sure? Managing dependencies correctly is a good way of applying other principles, like the Open-Closed.
One of the \ac{SOLID} principles, inversion of control, states that one should "Depend upon Abstractions. Do not depend upon concretions."
Dependency Injection is one of the implementations of this principle.



In general there are 3 ways an object can use another one:
\begin{enumerate}
	\item With a \texttt{new} operator
	\item Using global variables
	\item Pass in the dependency to where it is needed
\end{enumerate}

\lstinputlisting[language=javascript, caption={Hard-coded dependencies}]{src/design-di-1.js}

\lstinputlisting[language=javascript, caption={Passing on the reference (without service locator)}]{src/design-di-handling-dependency-to-component.js}

In LISTING 1 dependencies are hard-coded.
In LISTING 2 MasterGreater is not concerned with locating the \texttt{greeter} dependency, it is simply handed the \texttt{greeter} at runtime.
This is desirable, but it puts the responsibility of getting hold of the dependency on the code that constructs \texttt{MasterGreater}.


\textbf{Inversion of control} means that objects do not create other objects on which they rely to do their work.
They get the dependencies from an outside source (e.g. an XML configuration file).
\textbf{Dependency Injection} means that this is done in a transparent way for the object.
The dependency is supplied to the software component.

The framework encourages the use of this pattern in all components. 
More specifically, the framework uses a Service Locator \fref{fig:design-service-locator} (called \texttt{injector}) to manage the responsibility of dependency creation.
Thus, services can be used in controllers and directives by their name.
The client class does not need to know the concrete implementation of the service. 
With this principle it is easy to mock classes for unit testing and change components in general.
A particular implementation of this principle is in the wrapper for roslibjs: the service palROSBridge in the application is made injectable and provides callbacks to allow a decoupled desing. FIXME LANGUAGE.

With AngularJS, injectable components are created with a factory and are made available using a global injector.
They can be injected just by using their name.

\lstinputlisting[language=javascript, caption={Injecting services in a controller}]{src/design-di-injection.js}

They can be obtained manually with the \$injector

\lstinputlisting[language=javascript, caption={Manual injection (e.g. in a test)}]{src/design-di-manual-injection.js}

\paragraph{Factory} Directives, controllers, services... are registered on modules. 
The $module.directive$ \ac{API} registers them. 
It takes a normalised name and a factory function \fref{fig:design-factory} that returns an object with the fields that can be exposed to classes that use it.
For example, a Directive Definition Object or a Service.
\lstinputlisting[language=javascript, caption={Example of Factory}]{src/design-di-factory.js}


\paragraph{Revealing Module} \cite{Osmani:2012} Modules typically help in having the units of code for a project separated.
JavaScript does not support the concept of classes but it does support special constructor functions that work with objects. 
The $new$ keyword used in a call to a constructor function makes JavaScript instantiate the new object with members defined by that function.
Modules are a way to emulate the concept of classes.
There are several options to implement them. 
This project uses object literal notation (CROSS REF JAVASCRIPT)
The module pattern encapsulates privacy, state and organisation using closures (CROSS REF JAVASCRIPT)
Only a public \ac{API} is returned, keeping everything else hidden within the closure private.
With the Revealing Module Pattern the code of the module is simplified: all variables and functions are defined in the private scope and returns an anonymous object with pointers to the private properties that should be revealed.
FIXME CROSS REF factory code example  + annotation "compare to writing the code of the function right there"

\paragraph{Remote Facade} FIXME: sure? do I have a remote facade in the app, in a controller?

\paragraph{command pattern} cita el general i cita osmani \cite{Osmani:2012}

FIXME posar diagrames per algun lloc 


\subsection{Orientation to Web Components}

\section{Static View}
the model, the view and the controllers. angualar modules, services, filters, controllers...
talk about the data model and \$rootScope ? talk about properties

un diagrama:
moduls, serveis, controladors, etc. 

\section{Dynamic view}
the flow: user creates an application, [robot sync], my app reads it and generates HTML output.

specific flow of an app. bootstrap, the compile-link phase, push classes, push styles, get url params, etc.
examples of using the properties, generating the settings, fetching things from the server, rostopics...

\section{Physical view}
robots, backend.basestation, wi-fi, vpn...

\section{External view}
there isn't! it's a backend app to create a frontend app.

\section{should there be any more sections?}
something more
