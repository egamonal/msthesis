\chapter{Requirements}
Requirements can be gathered using interviews with customers, users and stakeholders, with observation, questionnaires, prototyping or even from an existing application.
In this project requirements are obtained mainly from the current implementation of the software (\fref{sec:reengineering}) and from interviews with the developer of the old version.
Some features, either deprecated or with low priority, are left out of the requirements list due to time constraints. 

\section{Functional Requirements}

\subsection*{Ready-made Solutions}
Since this is a very specific software, there are no off-the-shelf solutions available that meet the requirements of the project.
However, there are libraries and frameworks that can be reused:

\begin{enumerate}
    \item JavaScript frameworks
    \begin{itemize}
        \item \ac{MVC}: AngularJS, Spine, Ember.js, Knockout.js, Sprout, Google Closure
        \item Oriented to Web Components: AngularJS, Polymer
        \item BackBone.js
    \item Testing: Jasmine, qUnit, phantomJS   
    \end{itemize}
    \item JavaScript libraries
    \begin{itemize}
        \item jQuery and plug-ins: Bigvideo.js, jQuery-ui, jquery-mobile , jquery-kinetic  
        \item Hammer.js, jGestures , iScroll, swipe.js
    \end{itemize} 
    \item \ac{CSS} Tools: LessCSS, SASS
\end{enumerate}

\subsection*{Constraints}
Certain constraints were defined before the beginning of the project:
\begin{enumerate}
    \item Technology: the project has to be implemented using modern web technologies (\ac{HTML5}, JavaScript, \ac{CSS}).
    \item Legal: It has to be ready to be open source
\end{enumerate}

\subsection*{Functional Requirements}
\begin{enumerate}
    \item \textbf{Render \ac{UI} Components with \ac{HTML}}. \ac{UI} components, currently defined with \ac{XML}, have to be eventually transformed to \ac{HTML} so that a browser can render them.
    \begin{enumerate}
        \item Support for \textbf{multiple languages} via the parameter \texttt{lang}.
        \item \textbf{Components} 
        \begin{enumerate}
            \item \textbf{Basic components} \texttt{screen}, \texttt{subscreen}, \texttt{textarea}, \texttt{img}, \texttt{button}, \texttt{video}, \texttt{showreel}, \texttt{swf}, \texttt{layout}, \texttt{qr}.  Exclude: \texttt{group}, \texttt{group\_button}.
            \item \textbf{Theme components}.
            \item \textbf{Properties inline or in tags}. \texttt{x}, \texttt{y}, \texttt{width}, \texttt{height}, \texttt{scrolly}, \texttt{scrollx}, \texttt{loop}, \texttt{loopy}, \texttt{loopx}, \texttt{src}, \texttt{style}, \texttt{caption}.
            \item \textbf{Action} properties \texttt{onclick}, \texttt{onload}, \texttt{action}, \texttt{param}.
        \end{enumerate}
        
    \end{enumerate}
    \item \textbf{Themes}. The current version has a default theme, a set of \ac{UI} components that extend the basic ones and provide a certain look and feel. All theme components are eventually implemented with a basic component, e.g. a \texttt{back-button}, a \texttt{home-button}, a \texttt{base-button}, etc.
    \item Internal \textbf{navigation} (subscreens). Subscreens are containers whose content is determined by the \ac{URI}.
    \item \textbf{Settings} management. There are three configurations to load: generic settings (default language, paths...), application specific settings (current language, current theme...) and structure of the application (a graph that defines an $id$ and a \ac{URI} for each node (screen)).
    \item Basic support for \textbf{Entities}.
\end{enumerate}

\section{Non-Functional Requirements}
\begin{enumerate}
    \item \textbf{Target browser}: QtWebKit (Qt 5.0.x) for the first phase, Google Chrome 28 for the second.
    \item \textbf{Extensibility}: The software has to be extensible. The design has to allow adding new features in the future.
    \item \textbf{Robustness}: the software has to be reliable and has to be delivered with a comprehensive test suite. It should be compatible with Jenkins and continuous integration.
    \item \textbf{Hardware}: the software has to perform smoothly in Reem H3 and a multitouch screen.
    \item \textbf{\ac{UX}}: the time to change to another screen in the rendered content application should be less than 0.5s. Media contents (images, videos) have to be ready in less than 1s after a screen change. Rendered components should be aesthetically pleasant.
    \item \textbf{Interoperability}: it has to interoperate at least with:
    \begin{itemize}
        \item \textbf{Backend}: there is an \ac{API} in a Django backend that provides settings and serves the contents
        \item \textbf{RobotBehaviour}: the Qt program that runs in the robot and governs the behaviour. Sometimes the touchscreen displays Qt windows, sometimes it displays the content applications. 
    \end{itemize}
\end{enumerate}