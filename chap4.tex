\chapter{Requirements}
Requirements can be gathered using interviews with customers, users and stakeholders, with observation, questionnaires, prototyping or even from an existing application.
In this project requirements are obtained mainly from the current implementation of the software (\fref{sec:reengineering}) and from interviews with the developer of the old version.
Some features, either deprecated or with low priority, are left out of the requirements list due to time constraints. 

\section{Stakeholders}
maybe this subsection is not needed

\section{Functional requirements}

\subsection{Ready-made solutions}
Because this is a very specific software, there are no off-the-shelf solutions available that meet the requirements of the project.
However, there are libraries and frameworks that can be reused:

TODO: Add description or a few more details (?)

\begin{enumerate}
    \item JavaScript frameworks
    \begin{itemize}
        \item \ac{MVC}: AngularJS, Spine, Ember.js, Knockout.js, Sprout, Google Closure
        \item Oriented to Web Components: AngularJS, Polymer
        \item BackBone.js
    \item Testing: Jasmine, qUnit, phantomJS   
    \end{itemize}
    \item JavaScript libraries
    \begin{itemize}
        \item jQuery and plug-ins: Bigvideo.js, jQuery-ui, jquery-mobile , jquery-kinetic  
        \item Hammer.js, jGestures , iScroll, swipe.js
    \end{itemize} 
    \item \ac{CSS} Tools: LessCSS, SASS, Bootstrap
\end{enumerate}

\subsection{Glossary}

\subsection{Domain properties and hypothesis}
\subsection{Constraints}
Certain constraints are defined before the beginning of the project:
\begin{enumerate}
    \item Technology: the project has to be implemented using modern web technologies (\ac{HTML5}, JavaScript, \ac{CSS}).
    \item Legal: It has to be ready to be open source
\end{enumerate}


\subsection{Functional requirements}
\begin{enumerate}
    \item Render \ac{UI} Components with \ac{HTML}. \ac{UI} components, currently defined with \ac{XML}, have to be eventually transformed to \ac{HTML} so that a browser can render them.
    \begin{enumerate}
        \item Support for multiple languages via the parameter lang.
        \item Components 
        \begin{enumerate}
            \item Basic components screen, subscreen, textarea, img, button, video, showreel, swf, layout, qr.  Exclude: group, group\_button.
            \item Theme components. FIXME: add list and exclusions.
            \item Properties inline or in tags. x, y, width, height, scrolly, scrollx, loop, loopy, loopx, src, style, caption.
            \item Action properties onclick, onload, action, param.
        \end{enumerate}
        
    \end{enumerate}
    \item Themes. The current version has a default theme, a set of UI components that extend the basic ones and provide a certain look and feel. All theme components are eventually implemented with a basic component, e.g. a back-button, a home-button, a base-button, etc.
    \item Internal navigation (subscreens). Subscreens are containers whose content is determined by the url.
    \item Settings management. There are three configurations to load: generic settings (default language, paths...), application specific settings (current language, current theme...) and structure of the application (a tree that defines an id and a \ac{URL} for each node (screen)).
    \item Entities support. FIXME out of scope
    \item Screen saver / Sessions FIXME out of scope
\end{enumerate}

\section{Non Functional Requirements}
TODO: maybe add: political, economic, structural, quality
FIXME: add measurable stuff

\begin{enumerate}
    \item Target browser: QtWebKit (Qt 5.0.x) (FIXME! maybe chrome)
    \item Extensibility: The software has to be extensible. The design has to allow adding new features in the future.
    \item Robustness: the software has to be reliable and has to be delivered with a comprehensive test suite. It should be compatible with Jenkins and continuous integration.
    \item Hardware: the software has to perform smoothly in Reem H3 and a multitouch screen.
    \item \ac{UX}: the time to change to another screen in the rendered contents application should be less than 0.5s. Media contents (images, videos) have to be ready in less than 1s after a screen change. Rendered components should be aesthetically pleasant.
    \item Interoperability: it has to interoperate with:
    \begin{itemize}
        \item Backend: there is an \ac{API} in a Django backend that provides settings and serves the contents
        \item RobotBehaviour: the Qt program that runs in the robot and governs the behaviour. Sometimes the touchscreen displays dialogs from Qt, sometimes it displays the application contents. 
    \end{itemize}
\end{enumerate}

TODO: maybe add software quality factors