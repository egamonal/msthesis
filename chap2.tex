%% This is an example first chapter.  You should put chapter/appendix that you
%% write into a separate file, and add a line \include{yourfilename} to
%% main.tex, where `yourfilename.tex' is the name of the chapter/appendix file.
%% You can process specific files by typing their names in at the 
%% \files=
%% prompt when you run the file main.tex through LaTeX.

fix the abstract to include UPC (currently only FIB is shown)
\cite{Darwin} \cite{Crockford} \cite{Stefanov} \cite{AngularJSGuide} \cite{Fowler}


\chapter{Related Work}
This chapter is a short introduction to.. general concepts. doesnt make references to
robots, qt or anything. no ref to UX or UI design. my problem is an app that renders
apps, not the screens editor or a particular design.

\section{Systems Reengineering}

\section{Web Technologies}
% quotations: something about emacs life style, or berners lee
The \ac{WWW} plays a central role in many people's lives.
The first drafts date back to the 1980s, the first web browser prototype by Tim Berners-Lee was built in December 1990 and the Mosaic browser was completed in 1993.
After that, Netscape, Mozilla Firefox, Microsoft Internet Explorer, Google Chrome, Safari, Opera, Konqueror and many other browsers appeared, along with some nowadays popular websites (e.g. amazon.com 1995).

For many people the browser is the most used software in many devices. 
The web creates opportunities and makes documents accessible like tax records, maps, banking information, phone directories or product catalogues.
New business models, like new ways of promoting products, selling music or movies, are developed having the web as a core part.
Innovation goes beyond all these with experiments and products like FirefoxOS or ChromeOS to build an operating system designed to mainly let the user browse the web. 
Other companies, like Citrix or eyeOS, offer web applications that resemble an operating system %\cite{Gamonal:2011}.

%goals: explain evolution of web tech, state of the art, and why it is better than flash.

%* programs in browsers. isolate them? flash plugin. flash is dead (jobs or other
%articles) 
%* browsers: architecture (dom, js engine, html renderer...) from mosaic to
%%fx/ch/qtwebkit 
%** webkit and qtwebkit
%
%* client-side tech: JS, css, html/xml 
%** evaluation and comparison 
%** frameworks
%
%browsers, JS engines, chrome v8, fx gecko, QtBrowser
% functionaliyy (interoperability, security), reliability (maturity), usability: (learn-
%ability, attractiveness) Efficiency: (time behavior, resource utilization) Maintainabil-
%ity: (stability) Portability: (installability)

\subsection{From Plain Documents to Applications}
\paragraph{The Evolution of the Web}
"HyperText is a way to link and access information of various kinds as a web of nodes in which the user can browse at will. Potentially, HyperText provides a single user-interface to many large classes of stored information such as reports, notes, data-bases, computer documentation and on-line systems help" \cite{BernersLee:1990}

When the \ac{WWW} was started in 1990 it was intended to be a document viewing platform. It has evolved in at least three phases \cite{Anttonen:2011} \cite{Taivalsaari:2008}:
At first, documents were just plain text, forms and page-structured artifacts, possibly static images and hyper-links (anchors) to provide navigation. 

Later on, browsers added programming capabilities, plug-ins and allowed animated graphics. Web pages became interactive and client-server communication increased in complexity.
Adobe Flash (at that time Macromedia Flash), ShockWave, Java, QuickTime and a few others allowed the inclusion of multimedia contents or even programs (e.g. Java Applets).

More recently, despite the fact that the web browser was not designed for running applications, since 2008 users have headed this way. 
In this third phase, web pages are not just documents: they have complex user interaction capabilities, they do not require full page refresh and typical use cases have evolved. 
It is not only about viewing documents but about world-wide sharing, collaboration and interaction, possibly in real time. 

Web browsers have become a widely-used platform for software applications. 
Video editors, spreadsheets, calendars or 3D games used to run exclusively on desktop computers. 
Today, they run in a variety of devices and some of them even do it in a browser. 
There are 3D engines ported to web, real time collaboration, full HD video without plug-ins and many more features built-in a system that is not an ideal execution environment for desktop applications.

\paragraph{\acp{RIA}}
\acs{RIA} are neither web services or web pages. 
They are software systems based on technologies and standards of the \ac{W3C} that provide web specific resources such as content and services through a web browser \cite{Kappel:2006}.
Typically one designs them as single page websites.

% FIXME language
Web applications differ a lot between them. 
They can be document-centered, workflow-based, portal-oriented, collaborative, social, etc. 
They all have some common characteristics. Amongst others:
\begin{itemize}
    \item The product
    \begin{itemize}
        \item Content is the core.
        \item Hyper-text: non-linearity is a main distinction to traditional software systems. There are many ways of landing on a certain page. This can lead to disorientation or cognitive overload for users.
        \item Presentation aesthetics, usability and interaction are closer to a desktop application than to a web page
    \end{itemize}
    \item Use
    \begin{itemize}
        \item Globality: Spontaneity and multiculturality of users. Web applications are publicly available.
        \item Quality suffers from unknown network characteristics
        \item Multiplaform delivery involves having different devices, browsers and degrees of functionality and performance
        \item Intense network usage. Remote calls are to be minimised. The use of software patterns like remote facade, remote proxy, DTO or RPC is frequent
    \end{itemize}
    \item Evolution
    \begin{itemize}
         \item Continuous change
         \item Competitive pressure
         \item Fast pace development
    \end{itemize}   
\end{itemize}

The project of this thesis is, in a sense, both a \ac{RIA} and a \acp{RIA} generator. 
It is a \ac{RIA} because, among other reasons, it works in the browser with web technology and has an intense use of the network to fetch the model or other components to build the screens.
The rendered application works in a browser, has an intense use of the network as well and is content-centered.
Despite the fact that it works in the specific content of a robot, globality is still an issue. A typical scenario would be a fleet of robots in a conference: users from many different cultural backgrounds can use the application at any time.



%    * from old plain html to RIA 
%    * browse docs to single page apps

\subsection{Browsers and isolation of programs}    
Many of the websites in the aforementioned third phase contain substantial amounts of client-side code. At the end of the day, a \ac{RIA} is a distributed software. 
In the old days the client-side part was thin and simple, whereas today's application have complex logic delegated to client nodes with local storage, hardware-accelerated components, websockets and other advanced capabilites.

In spite of the fact that \acp{RIA} have grown in complexity and now demand more resources, browsers architectures still do not provide sufficient isolation between concurrently executing programs.
A similar problem occurred in early operating systems (e.g. MS-DOS), before processes appeared \cite{Reis:2009}. 

Browsers have typically the following components: TODO

Most of browsers have a monolithic architecture with poor isolation between web application instances. Chromium, however, implemented an architecture based on OS processes. Another way of isolating web applications is running them in a plug-in container. 

The project of this thesis uses Qt WebKit, the port of WebKit on top of Qt, to display the application in a Qt dialog and communicate with the hardware. Qt WebKit components comprise the WebCore and SquirrelFish Extreme, which compiles Javascript into native machine code. It is compatible with Adoble Flash Player but because it will not receive more updates in the future, it will not be used any more.
The Flash plugin is a black box isolated from other elements in the \ac{DOM}. Isolation is not an issue in this project because there is only one application running at a time.


\section{Client-side Technology}

\subsection{Comparison of languages}
\subsection{Frameworks}

\section{Test-Driven Development}
\section{XML as an intermediate representation}


\chapter{Plan}
check section name (roadmap?). check contents.
description of the dev process: research, write small pieces of code, intense unit testing, refactoring, TDD...

\section{Phases}
4 phases: proof of concept, first iteration, second, report (?). gantt
\section{Budget}
numbers here.
\section{Execution}
progress, deviations, final cost


\chapter{Requirements}
\section{Stakeholders}
maybe this subsection is not needed
\section{Scope}
scope of the project. what will be done and what will not. e.g backend.basestation, old xml syntax.

\section{Functional requirements}
do we need a section somewhere about DSL? is our XML a DSL?
basically, make it work and make it work fast. test. deploy it. make it compatible with backend

\section{Non Functional Requirements}
intense testing, robust application, modern standards, easy to maintain, specific platform, specific hardware, touchscreen, UI/UX/usability

\chapter{Specification}
uhms, I don't think this section will have interesting diagrams.
should it contain the theory? DSL, XML (vocabulary, grammar, motivations), intercommunication with other systems (config files, structure.xml...)

Users: no users (well, a "virtual" user does exist). it's a meta-app that reads apps in xml and renders them in html. define input and output.

contracts: no contracts. TDD as opposed to design by contract??? check literature

Use Cases: one per directive, settings and entities?? users: the system.

\chapter{Design}
internal design of the application. this should be the fun part.
\section{Technology}
angularJS (teach the browser new syntax), javascript, html5, Qt, QtBrowser and its limitations (JS engine vs chrome v8 or firefox's).

\section{Architecture}
MVC. client-side. JSON to talk to an API. xml files as angularjs partials, hacks to make it work (routes defined manually, one controller for all of them, dirty entities). scopes and their specific use here (compare to regular use)

dependency injection and angularJS (and literature: fowler)

\section{Static View}
the model, the view and the controllers. angualar modules, services, filters, controllers...
talk about the data model and \$rootScope ?

\section{Dynamic view}
the flow: user creates an application, [robot sync], my app reads it and generates HTML output.

specific flow of an app. bootstrap, the compile-link phase, push classes, push styles, get url params, etc.

\section{Physical view}
robots, backend.basestation, wi-fi, vpn...

\section{External view}
there isn't! it's a backend app to create a frontend app.

\section{should there be any more sections?}

\chapter{Implementation}
\section{Development environment set-up}
webstorm, chrome+batarang, firefox+firebug, karma, qtwebkit, qt5 and qt4, linux, ssh to access the robots and basestation, python, virtual environments, svn, robot code, run levels (htmldialog, guiServer, statemachine (WARNING: CONFIDENTIAL?): motivation and benefits.

\section{Examples (application)}
this is gonna be too big. should examples be included somewhere else?

include examples about: a service, a simple directive, a controller (and the execution flow?).

include directive examples: normal (back-button), with isolated components (subscreen), and entities (data and loop)

\chapter{Testing}
i'm gonna enjoy myself here.
TDD, karma, unit tests, specification with tests, safe refactoring, integration of karma in webstorm, tweak karma to run in Qt...
quality factors of a webapp: kappel


\chapter{Future Work and Conclusions}
\section{Future Work}
\section{Conclusions}