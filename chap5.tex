\chapter{Specification}
The specification of the program defines what it does rather than how.
This chapter presents the specification of the system taking into consideration general software engineering principles, like the models proposed by Larman (FIXME CITE??)(at least conceptual, use case and behaviour models) and Meyer's (FIXME CITE??) \ac{DbC}.
For the particular case of this thesis, the specification takes into account reengineering principles and procedures and \ac{TDD} as a tool to define what the system does as opposed to a simple testing technique.

Reengeneering software comprises 6 activities (TODO Maybe cross ref chapter 2): 
\begin{enumerate}
    \item Inventory Analysis
    \item Documentation reestructure (FIXME Language)
    \item Reverse Engineering
    \item Code Restructuring
    \item Data Restructuring
    \item Forward Engineering
\end{enumerate}   
   
The outcome of these activities (FIXME: activity, task?) derives part of this specification.
For example, use cases are extracted from the current system.
The first three focus on what the system does and are used in this chapter, whereas the last three are highly coupled to technology and are expanded in chapter design (FIXME cross ref chapter 6?).

\section{Inventory Analysis}
list software, current status, etc and whatever pressman says


\begin{inventory}{name=yeha, year=2000}

\end{inventory}
%\inventory{name=aloha}
    



    name of the application
    year it was originally created
    number of substantive changes made to it
    total effort applied to make these changes
    date of last substantive change
    effort applied to make the last change
    system(s) in which it resides
    applications to which it interfaces
    database(s) that it accesses
    errors reported over the past 18 months
    number of users
    number of machines on which it is installed
    complexity of 

        program architecture
        code
        documentation 

    quality of documentation
    overall maintainability (scale value)
    projected longevity (in years)
    projected number of changes over the next 36 months
    annual cost of maintenance
    annual cost of operation
    annual business value
    business criticality 
    
    The following checklist may help to determine which applications are candidates for reengineering. The more questions that receive a positive ("yes") response, the higher the probability that the application is a candidate for reengineering.

    Is the application more than five years old?
    Is the application business critical?
    Is the project longevity projected to be more than five years?
    Is the number of users large by local standards?
    Is the number of users likely to increase?
    Are major changes contemplated for the application?
    If so, will these major changes require substantial commitent of effort by local standards?
    Is the cost of continuing annual maintenance known?
    Is the annual value of the application known?
    Is the projected total cost of change known?
    Can the cost to reengineer the application be estimated to within 20%?
    If so, is reengineering cost less than the cost to make changes plus the cost of maintenance?

\section{Document reestructure}
maybe we don't need this.

\section{Reverse Engineering}
\label{sec:context}
Reengeneering a software involves reverse engineering, understanding what the system does.

There are 3 key issues in understanding the current system: abstraction level, completeness and direction.
This specification uses a system-level abstraction, only takes into account interaction with external actors, and is one-way (from current system to the specification of the new system).
Other levels of abstraction do not apply here to keep this specification technology-agnostic.

\subsection{Context}
\begin{figure}[htb]
    \label{fig:context-original}
    \centering
    \includegraphics[width=\textwidth]{figures/context-original}
    \caption{Current context}
\end{figure}

\begin{figure}[htb]
    \label{fig:context-new}
    \centering
    \includegraphics[width=\textwidth]{figures/context-new}
    \caption{New context}
\end{figure}

Key aspects when understanding the current program include the interaction, interoperability and the context.
ReemH-3 has about 600MB of specialised code and uses up to 13GB to store the operating system, libraries and other tools.
The program that manages the state machine is \textbf{robotBehaviour}, a \texttt{Qt} program that glues all software parts and serves as an interface to the hardware.
A dialog in this program contains a QtWebKit widget, the embedded web browser that loads the contents shown in the touchscreen.
Contents are fetched from Basestation, a server that hosts \textbf{Flango Frontend}, a web application (Django + Flash) that lets users edit screens, add media contents and synchronise them with robots (\fref{fig:context-original}).
The Frontend has an \ac{API} to serve the contents applications to the robots.
The project of this thesis is reengineering the \textbf{Flango Content Manager}, in the robot (\fref{fig:context-new}).

\subsection{Interaction}
\begin{figure}[htb]
    \label{fig:interaction-original}
    \centering
    \includegraphics[width=0.7\textwidth]{figures/interaction-original}
    \caption{current interaction}
\end{figure}

\begin{figure}[htb]
    \label{fig:interaction-new}
    \centering
    \includegraphics[width=0.7\textwidth]{figures/interaction-new}
    \caption{New interaction}
\end{figure}

The content manager's input is \ac{XML} files and the output is an \ac{HTML} single page application (\fref{fig:interaction}).

\begin{enumerate}
    \item The robot boots
    \item robotBehaviour fetches settings (\ac{XML}) from Basestation: generic settings, contents application-specific settings and the structure.
    \item The Content Manager uses the settings to decide which application to load, the language, the theme, etc. and requests the screens (the \ac{XML} files) to Basestation
    \item Basestation serves all the screens
    \item The Content Manager renders the screens. If during this process encounters an "entity", it fetches the data from Basestation.
\end{enumerate}


\subsection{Interoperability}
\begin{figure}[htb]
    \label{fig:interoperability-original}
    \centering
    \includegraphics[width=0.7\textwidth]{figures/interoperability-original}
    \caption{Current interoperability (in robot)}
\end{figure}

\begin{figure}[htb]
    \label{fig:interoperability-new}
    \centering
    \includegraphics[width=0.7\textwidth]{figures/interoperability-new}
    \caption{New interoperability (in robot)}
\end{figure}

Flango Content Manager interoperates with two systems: robotBehaviour and Basestation.

\paragraph{robotBehaviour} Flango can interact with the hardware of the robot through robotBehaviour, e.g. using text-to-speech capabilities, triggering a batch action (autopresentation, guide user to a certain place...).
Likewise, robotBehaviour uses an API in Flango, e.g. to restart a session or to input information gathered with the robot's hardware.
There is an interface defined for this to allow independent development in both ends.
Notice that figures \fref{fig:interoperability-original} and \fref{fig:interoperability-new} do not show Basestation. See \fref{fig:context-original} and \fref{fig:context-new}.
The current system to exchange messages between the Flash container and robotBehaviour is based on JavaScript callbacks.
To send a message to robotBehaviour:
\begin{enumerate}
    \item Flash opens a new tab with a specific url: \texttt{flashCallback.html?\textless paramList\textgreater}
    \item robotBehaviour intercepts the call, prevents QtWebKit from opening a new tab and executes an action specified with the parameters
\end{enumerate}

To send a message from robotBehaviour:
\begin{enumerate}
    \item Calls a \ac{JS} function in the Flash container (\texttt{/static/frontend/index.html})
    \item The container forwards this call to the Flash container
    \item The application facade of Flango Content Manager takes required action
\end{enumerate}

The requirements state that the new software has to be implemented using web technology. 
Despite the fact that this specification should be technology agnostic, to integrate the new software better in the system, the use of ROS Web Tools is suggested to exchange messages.
In any case, it is clear that there has to be an interface between robotBehaviour and the browser, as they run in separate processes (as opposed to sharing at least one parent process in the current implementation).

\paragraph{BaseStation (Flango Backend API} The Content Manager has to fetch data from Basestation in order to load the correct contents.
Flango Backend (TODO EPIC FIXME. fix the diagrams and everything. BS has backend and frontend) has an API for this:

\begin{table}[ht]
    \centering
    \label{tab:milestones}
    \begin{tabularx}{\linewidth}{| l | X |}
    \hline
    Root URL & Matching URLs \\
    \hline
    \multirow{2}{*}{\texttt{flango-api-0.1/robots}}
        & get\_robots \\ 
        & add\_robot \\
    \hline 
    
    \multirow{2}{*}{\texttt{flango-api-0.1/bl}} 
        & entity/(\textless entity\_name\textgreater).xml \\ 
        & add\_robot \\
    \hline
    
    \multirow{6}{*}{\texttt{flango-api-0.1/pal}} 
        & home \\
        & add \\
        & execute \\
        & status \\   
        & submit \\
        & history/(\textless page\textgreater) \\
    \hline
    
    \multirow{10}{2.5cm}{\texttt{flango-api-0.1/gui}  \texttt{flango-api-0.1/app}}
        & \textless app\_id\textgreater /config.\textless format\textgreater xml$|$json \\
        & \textless app\_id\textgreater /structure.\textless format\textgreater xml$|$json \\
        & \textless app\_id\textgreater /screen/( \textless screen\_id\textgreater.xml \\
        & \textless app\_id\textgreater /node/\textless node\_id\textgreater \\
        & application \\
        & node \\
        & screen \\
        & allScreens \\
        & getApps \\
        & upload\_app \\
    \hline
    
    \multirow{7}{*}{\texttt{flango-api-0.1/stats}}
        & robot/use/<robotID>/<duration>/<data> \\
        & robot/base \\
        & app/use/<robotID>/<duration>/<data> \\
        & app/top/<robotID>/<duration>/<data> \\
        & app/toptable/<page> \\
        & application/<screen> \\
        & <name> \\
    \hline
    \end{tabularx}
    \caption{Flango Backend API}
\end{table}
Both current and new implementation use this.
However, the new implementation uses \ac{JSON} because it is more \ac{JS}-friendly: it has less overhead and it is easier to deserialise.


\section{conceptual model}
TODO FIXME subindex in captions
\begin{figure}[htb]
    \label{fig:specification-conceptual-model-1}
    \centering
    \includegraphics[width=\textwidth]{figures/specification-conceptual-model-1}
    \caption{Conceptual model (a)}
\end{figure}

\begin{figure}[htb]
    \label{fig:specification-conceptual-model-2}
    \centering
    \includegraphics[width=\textwidth]{figures/specification-conceptual-model-2}
    \caption{Conceptual model (b)}
\end{figure}

There are only a few classes of objects in the system.
This project only reengeneers Flango Content Manager.
Because the Screens Editor (Flango Frontend) remains "as is", and the input of the new software is the output of this program, it has to be compatible with the current implementation.
Otherwise, users would create contents applications with the Screens Editor that would look different when they are displayed in the robot.
To ensure compatibility, it is necessary a good understanding not only at system level, but at component level.
It is required, then, that the new implementation can render consistently all of the \ac{UI} components that the Screens Editor can create and all of their properties. 
Same applies to settings and use of "entities".
Thus, there are at least 3 classes of objects: Setting, UI Component (and UI Theme Component), Entity.

A UI Component is an element of the \ac{UI}, for example a Button or an Image.
Users drag and drop them to a canvas in the Screens Editor to create the contents. 
All UI Components have an \ac{XML} code.
Because the domain of the problem and the classes are shared between the original and the new implementation, the model in \fref{fig:specification-conceptual-model-1} and \fref{fig:specification-conceptual-model-2} is created from the current implementation.
To support themes, there are two types of UI Components: basic (UI Component) and theme (UI Theme Component).
All UI Theme Component are eventually implemented with a basic UI Component.

\begin{lstlisting}[caption=Basic UI Components, label=onelabel]
ButtonComponent.as
GroupButtonComponent.as
GroupComponent.as
ImageComponent.as
MenuComponent.as
QRComponent.as
ScreenComponent.as
ScrollComponent.as
ShowReelComponent.as
SubscreenComponent.as
SWFComponent.as
TextareaComponent.as
UIComponent.as
VideoComponent.as
\end{lstlisting}

\begin{lstlisting}[caption=Theme UI Components, label=anotherlabel]
arabic_button
back_button
base_button
big_button
call_to_action_screen
camera_button
config_button
english_button
forward_button
home_button
info_button
korean_button
language_button
left_arrow_button
line
list_button
main_menu
next_button
reem_body_button
reem_button
right_arrow_button
smartphone_menu
synchronizing_screen
video_button
wide_button
\end{lstlisting}

\begin{lstlisting}[caption=Application State (Settings class), label=anotherlabel2]
api_endpoint:String
app_id:String
app_name:String
current_node:String
debug_level:String
debug_mode:Boolean
default_api_endpoint:String
def_lang:String
def_theme:String
enable_stats_bkp:Boolean
enable_stats:Boolean
history:Array
history_current:int
history_limit:int
home_node:String
initial_node:String
lang_list:Object
lang:String
log:String
media_path:String
performance_monitor:Boolean
perform_callbacks_bkp:Boolean
perform_callbacks:Boolean
redirects:Array
report_stats:Boolean
robot_id:String
scale_factor:Number
screensaver_node:String
screens:Object
screen_transitions:Boolean
security_level:int
session_fadeout:int
session_timeout:int
show_cursor:Boolean
static_api_endpoint:String
static_media_path:String
static_themes_path:String
structure:XML
theme_list:Object
themes_path:String
theme:String
themes:XMLList
zone:String

\end{lstlisting}

\ref{onelabel} and \ref{anotherlabel} contain a comprehensive list of UI Components extracted from listing the necessary files in a package of the current implementation.
Notice that all files in \ref{onelabel} have the corresponding class in the conceptual model.
The elements of \ref{anotherlabel} are in fact folders but they can be considered objects in this specification as they are part of the domain of the problem.
The state of the application is defined with DTOs sent from the server.
A collection of the necessary the attributes of the class that encapsulates the configuration is in \ref{anotherlabel1} and has been extracted from the current implementation as well.

Entities are classes that represent classes in the Screens Editor. 
Imagine the following scenario: Alice is creating screens with the Screens Editor.
She rented the robot for a congress and wants to add information about job openings in her company.
She can define, with Flango, an entity named "Job" and use it in the screens editor to show the list of all instances of Job.

A Contents Application can have themes.
There is a default theme that defines the look and feel of all UI Theme Components.
All themes have the same UI Theme Components to guarantee that themes can be changed safely.
Basic UI Components look always the same way.

TODO explain XML here? explain theming here? fallbacks? ambiguity?

TODO : maybe --- I can't remember what I was going to write here.
For instance, the \ac{XML} code of a Button UI Component in \fref{chap:specification-button-example-1}

\lstinputlisting[language=XML, caption={Basic UI Component Button XML}]{src/specification-button-example-1.xml}

DIAGRAM HERE


constraints?

\section{use case model}
This section describes the services of the system as sequences of events triggered by external actors.

\subsection{Actors}
Humans only interact directly with the output of this software (see \fref{sec:context}), which becomes the \ac{GUI}.
For example: the program renders a screen with one button whose action is to make Reem say "hi, my name is Reem".
The input is an \ac{XML} file, the output is a web \ac{GUI} ready to be used.
Humans can now touch the button that sends events to robotBehaviour so, essentially, the \ac{GUI} of the program and not only the output is built as a function of the input.
The actual actors are robotBehaviour, the basestation and, eventually, a user of the contents.


\subsection{System Use Cases}
Examining the current implementation at a program level one can determine a number of use cases:


system use cases:
configure app (generic settings, app-specific settings, structure with nodes and screens)
render UI (define XML syntax here ????. XML (vocabulary, grammar, motivations). one sub-usecase per UI component?)
render entity (use render UI)
navigate to URI
interoperate with robotBehaviour 
interoperate with BS (sync, fetch config)

\section{behaviour model}
seq diagrams of system operations

This thesis combines design by contract and tdd. basically, tests define the behaviour for specific cases and dbc defines the general behaviour. thus, there are no tests for edge cases or negative behaviours because conracts, and more specirfically preconditions, protect the component.
Advantages:
with tdd:
build only what is required now. keep it simple.
have a suite of automated tests for refactoring safely, continuous integration and regression testing.
drive design decisions from tests (from specs).
using formal specs (dbc):
higher code quality
less checks (preconditions)
design decisions derived from preconditions

Larman: system sequence diagram + Meyer: contracts of system operations
%http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.68.313&rep=rep1&type=pdf
"System Sequence Diagrams:
–
Identify system events and system operations
–
Identify system events and system operations
– Document sequence of interactions
• Contracts:
– Define the pre- and post-conditions for system
operations "


TDD specs:
clarify this is here because we write tests before writing code. tests are implemented with a certain framework and oriented to a certain technology but this chapter focuses on what the tests say and why we do it this way.
outline tests


Design by Contract and Test Driven Development are not at all mutually exclusive.
TDD is not about testing!! is about executable specs
"The first idea is about test-driven development not being a testing technique;
automatic tests only become ”tests” after having implemented all the functionality
being test-
driven
. Before that there is nothing to actually
test
and those artifacts
rather serve as executable
specifications
but not tests"

up to date documentation: a common problem is that docs are hardly ever updated


---
Extreme Programming advocates test driven development where tests are used
to specify the behavior of a program before the program code is actually written.
Together with using the simplest design possible and intention revealing program
code, tests are additionally used as a documentation of the program. However,
tests are not sufficient to completely define the behavior of a program because
they are only able to test properties of a program by example and do not allow to
state general properties. The latter can be achieved using formal specifications,
e.g. using Meyer’s design by contract % http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.68.313&rep=rep1&type=pdf

\section{XML Representation}
explain syntax here?