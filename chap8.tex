\chapter{Testing}
i'm gonna enjoy myself here.
TDD, karma, unit tests, specification with tests, safe refactoring, integration of karma in webstorm, tweak karma to run in Qt...
quality factors of a webapp: kappel

\section{Overview}
This chapter contains a description of how \ac{TDD} is applied to this project.
\ac{TDD} is explained in \fref{sec:testdrivendev}.
Angular ships with Jasmine, a framework to do \ac{TDD}, to make \ac{E2E} and unit tests.

\ac{E2E} simulate user interaction by writing scenario tests.
They describe the expected behaviour of the application given a state and an interaction.
Each test has commands (e.g. "click on button with $id = 3$") and expectations (e.g. "the background colour is now shiny red").

Unit tests are created before the code itself is written (i.e. they first specify the behaviour of the software and then test the implementation).
Each test focuses on an individual and small part of the code: given an initial situation, the unit testing framework runs the operation being tested and finally asserts the result.

This project only uses unit testing to specify and test directives, services and controllers.
It is not possible to conduct \ac{E2E} testing because the \ac{UI} is built in run-time.
this testing strategy fits well with normal \ac{CRUD} applications, when developers know about the use cases of the software.
The software of this thesis only deals with rendering contents applications, which can be of any nature.
If this thesis had focuses on reengineering one of the contents applications, \ac{E2E} would have been a useful tool.

\section{Tests Definition}
Tests are written using Jasmine, "a behaviour driven development framework for testing JavaScript code" \footnote{\url{http://pivotal.github.io/jasmine/}}.
Tests are grouped in test suites.
Test suites are \texttt{describe} blocks that contain tests in \texttt{it} blocks.

\lstinputlisting[label=test-example-generic,language=javascript, caption={Structure of a test suite}]{src/test-example-generic.js}

Listing \ref{test-example-generic} shows the structure of a test suite:
it can perform logic before and after each test (e.g. instantiate an object or flush \$http requests to guarantee that all tests start with the same system state and that do no test depends on another one).
All tests have the same pattern:
\begin{enumerate}
\item Set the initial situation (e.g. create an \ac{HTML} node)
\item Run an operation (e.g. compile the node)
\item Assert the results (e.g. expect a property in scope to have been set, or a counter to have been increased)
\end{enumerate}

\lstinputlisting[label=test-example-width,language=javascript, caption={Structure of a test suite}]{src/test-example-generic.js}

Listing \ref{test-example-width} demonstrates a real test. 
The \texttt{width} directive test suite (called simply "width") belongs to a test suite called "UI directive". 
It contains several\texttt{it} blocks that check one and only one result (e.g. the test for getting the value is called "should set the property to 40 for Catalan and 42 for French").
When karma runner executes all test suites, it creates a report with sentences like "UI directive: width directive should set the property to 42 for the default language".
The initial situation is an \ac{XML} node, the operation run is \$compile() and the asserts are the \texttt{expect()} operations.

\paragraph{Dependency injection} Even though the internal design of the application minimises the coupling of components and tries to maximise cohesion, there are dependencies between some classes.
This is critical when it involves remote requests or using operations that are defined in another user class (as opposed to using well-tested code in the Angular core).
It is then desirable to use (and re-use) mocks in tests.
Dependency injection allows tests to mock dependencies: it loads a module with a mocked dependency of the same name that simply returns hard-coded values but offers the same interface.
No modifications in the real component are needed.

\lstinputlisting[label=test-di,language=javascript, caption={Dependency injection in tests}]{src/test-di.js}

\ref{test-di} shows the implementation: modules are loaded to make them available to the test suite.
In the \texttt{beforeEach} clause it stores a reference to the injected element to a local variable.
Whenever a test calls an operation of the injected service, it will use the mock.

\begin{lstlisting}[label=test-mocks,language=javascript, caption={Mocks}]
var m = angular.module('reemi.mocks.palProperties', []);

m.service('palProperties', function () {
	this.toCSS = function (params) {
       return "color:red;";
	}
});
\end{lstlisting}

Mocks are components declared with the same name but in a different module (\ref{test-mocks}).
They are excluded from deployment to the robot.

\paragraph{Relevant tests}
annex


\section{Test Automation}
config
run